{
    "instructions": {
        "nop": {},
        "dmb": {},
        "add_pc_plus_immediate": {
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "lsl_immediate": {
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "lsl_register": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            }
        },
        "clz": {
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            }
        },
        "sxth": {
            "m": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "rotation": {
                "type": "u8"
            }
        },
        "tbb_h": {
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "cmp_register": {
            "n": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "cmp_immediate": {
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "cmn_immediate": {
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "mov_immediate": {
            "d": {
                "type": "u8"
            },
            "imm32_carry": {
                "type": "ThumbImmediateResult"
            }
        },
        "mvn_immediate": {
            "d": {
                "type": "u8"
            },
            "imm32_carry": {
                "type": "ThumbImmediateResult"
            }
        },
        "mov_register": {
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            }
        },
        "rrx": {
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            }
        },
        "ldrb_immediate": {
            "t": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "ldrsb_immediate": {
            "t": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "ldrh_immediate": {
            "t": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "ldrsh_immediate": {
            "t": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "ldr_immediate": {
            "t": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "ldrex": {
            "t": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "ldrd_immediate": {
            "t": {
                "type": "u8"
            },
            "t2": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "ldr_literal": {
            "t": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "it": {
            "firstcond": {
                "type": "u8"
            },
            "mask": {
                "type": "u8"
            }
        },
        "cb_n_z": {
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "i32"
            }
        },
        "bl": {
            "imm32": {
                "type": "i32"
            }
        },
        "bx": {
            "m": {
                "type": "u8"
            }
        },
        "blx": {
            "m": {
                "type": "u8"
            }
        },
        "b_cond": {
            "cond": {
                "type": "u8"
            },
            "imm32": {
                "type": "i32"
            }
        },
        "b": {
            "imm32": {
                "type": "i32"
            }
        },
        "bfi": {
            "d": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "lsbit": {
                "type": "u8"
            },
            "msbit": {
                "type": "u8"
            }
        },
        "udiv": {
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "sdiv": {
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "mul": {
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "umlal": {
            "dHi": {
                "type": "u8"
            },
            "dLo": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "umull": {
            "dHi": {
                "type": "u8"
            },
            "dLo": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "smull": {
            "dHi": {
                "type": "u8"
            },
            "dLo": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "mls": {
            "a": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "mla": {
            "a": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "sub_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "sbc_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "rsb_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "sub_sp_minus_immediate": {
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "sub_register": {
            "shift_res": {
                "type": "ImmShiftResults"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            }
        },
        "rsb_register": {
            "shift_res": {
                "type": "ImmShiftResults"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            }
        },
        "add_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "adc_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "add_sp_plus_immediate": {
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "tst_immediate": {
            "n": {
                "type": "u8"
            },
            "imm32_carry": {
                "type": "ThumbImmediateResult"
            }
        },
        "teq_immediate": {
            "n": {
                "type": "u8"
            },
            "imm32_carry": {
                "type": "ThumbImmediateResult"
            }
        },
        "tst_register": {
            "n": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "teq_register": {
            "n": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "and_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32_carry": {
                "type": "ThumbImmediateResult"
            }
        },
        "add_register": {
            "shift_res": {
                "type": "ImmShiftResults"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            }
        },
        "adc_register": {
            "shift_res": {
                "type": "ImmShiftResults"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            }
        },
        "stmdb": {
            "n": {
                "type": "u8"
            },
            "registers": {
                "type": "u32"
            }
        },
        "push": {
            "registers": {
                "type": "u32"
            }
        },
        "stm": {
            "registers": {
                "type": "u32"
            },
            "n": {
                "type": "u8"
            }
        },
        "pop": {
            "registers": {
                "type": "u32"
            }
        },
        "ldm": {
            "registers": {
                "type": "u32"
            },
            "n": {
                "type": "u8"
            }
        },
        "uxtb": {
            "m": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "rotation": {
                "type": "u8"
            }
        },
        "sxtb": {
            "m": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "rotation": {
                "type": "u8"
            }
        },
        "uxth": {
            "m": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "rotation": {
                "type": "u8"
            }
        },
        "ubfx": {
            "d": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "lsbit": {
                "type": "u8"
            },
            "widthminus1": {
                "type": "u8"
            }
        },
        "orr_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32_carry": {
                "type": "ThumbImmediateResult"
            }
        },
        "orr_register": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "eor_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32_carry": {
                "type": "ThumbImmediateResult"
            }
        },
        "eor_register": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "sbc_register": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "and_register": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "bic_register": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "bic_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32_carry": {
                "type": "ThumbImmediateResult"
            }
        },
        "mvn_register": {
            "m": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "lsr_immediate": {
            "m": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "asr_immediate": {
            "m": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "lsr_register": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            }
        },
        "asr_register": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            }
        },
        "strd_immediate": {
            "n": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "t2": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "str_register": {
            "n": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "strb_register": {
            "n": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "strh_register": {
            "n": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "ldrb_register": {
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "ldrh_register": {
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "ldr_register": {
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "strb_immediate": {
            "n": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "strh_immediate": {
            "n": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "str_immediate": {
            "n": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "strex": {
            "n": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "svc": {
            "imm32": {
                "type": "u32"
            }
        },
        "bkpt": {
            "imm32": {
                "type": "u32"
            }
        },
        "msr": {
            "n": {
                "type": "u8"
            },
            "mask": {
                "type": "u8"
            },
            "SYSm": {
                "type": "u8"
            }
        },
        "mrs": {
            "d": {
                "type": "u8"
            },
            "mask": {
                "type": "u8"
            },
            "SYSm": {
                "type": "u8"
            }
        }
    },
    "decoders": {
        "nop_t1": {
            "instruction": "nop",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "static_cast<void>(rinstr);"
            ],
            "def": {},
            "post_block": [
                "assert(rinstr.low == 0b1011111100000000U);"
            ]
        },
        "dmb_t1": {
            "instruction": "dmb",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert(rinstr.low == 0b1111001110111111U);",
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.high)) == 0b100011110101U);",
                "static_cast<void>(rinstr);"
            ],
            "def": {},
            "post_block": []
        },
        "add_pc_plus_immediate_t1": {
            "instruction": "add_pc_plus_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b10100U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<10U, 8U>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8<<2U);"
                    ]
                }
            },
            "post_block": []
        },
        "lsl_immediate_t1": {
            "instruction": "lsl_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b00000U);",
                "assert((Bm16::Slice1R<10U, 6U>(rinstr.low)) != 0x0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |= TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u16 imm5 = Bm16::Slice1R<10U, 6U>(rinstr.low);",
                        "const auto shift_res = Alu32::DecodeImmShift(0b00, imm5);"
                    ]
                }
            },
            "post_block": [
                "assert(shift_res.type == SRType::SRType_LSL);"
            ]
        },
        "lsl_immediate_t2": {
            "instruction": "lsl_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11101010010U);",
                "assert((Bm16::Slice1R<3U, 0U>(rinstr.low)) == 0b1111U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);",
                "assert((Bm16::Slice1R<5U, 4U>(rinstr.high)) == 0b00U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u16 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u16 imm2 = Bm16::Slice1R<7U, 6U>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(0b00U, (imm3<<2U) | imm2);"
                    ]
                }
            },
            "post_block": [
                "assert(shift_res.type == SRType::SRType_LSL);",
                "assert(((imm3 << 2U) | imm2) != 0b0U);",
                "if (d == 13U || d == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "lsl_register_t1": {
            "instruction": "lsl_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 6U>(rinstr.low)) == 0b0100000010U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": []
        },
        "lsl_register_t2": {
            "instruction": "lsl_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11111010000U);",
                "assert((Bm16::Slice1R<15U, 12U>(rinstr.high)) == 0b1111U);",
                "assert((Bm16::Slice1R<7U, 4U>(rinstr.high)) == 0b0000U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15 || n == 13U || n == 15 || m == 13U || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "clz_t1": {
            "instruction": "clz",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110101011U);",
                "assert((Bm16::Slice1R<15U, 12U>(rinstr.high)) == 0b1111U);",
                "assert((Bm16::Slice1R<7U, 4U>(rinstr.high)) == 0b1000U);"
            ],
            "def": {
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm_1 = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u16 Rm_2 = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "if (Rm_1 != Rm_2) {",
                        "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                        "}",
                        "const u8 m = static_cast<u8>(Rm_1);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15 || m == 13U || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "asr_immediate_t1": {
            "instruction": "asr_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b00010U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<10U, 6U>(rinstr.low);",
                        "const auto shift_res =Alu32::DecodeImmShift(0b10U, imm5);"
                    ]
                }
            },
            "post_block": []
        },
        "cmp_register_t1": {
            "instruction": "cmp_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<10U, 6U>(rinstr.low)) == 0b01010U);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, 0U};"
                    ]
                }
            },
            "post_block": []
        },
        "cmp_register_t2": {
            "instruction": "cmp_register",
            "encoding": "t2",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<10U, 8U>(rinstr.low)) == 0b101U);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 N = Bm16::IsolateBit<7U>(rinstr.low);",
                        "const u16 Rn = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(N<<3U | Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<6U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, 0U};"
                    ]
                }
            },
            "post_block": [
                "if (n < 8U && m < 8U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (n == 15U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "cmp_register_t3": {
            "instruction": "cmp_register",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111010111011U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);",
                "assert((Bm16::Slice1R<11U, 8U>(rinstr.high)) == 0b1111U);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u16 type = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                        "const u16 imm2 = Bm16::Slice1R<7U, 6U>(rinstr.high);",
                        "const u16 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2) | imm2);"
                    ]
                }
            },
            "post_block": [
                "if (n == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "cmp_immediate_t1": {
            "instruction": "cmp_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b00101U);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<10U, 8U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            }
        },
        "cmp_immediate_t2": {
            "instruction": "cmp_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 4U>(rinstr.low)) == 0b011011U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);",
                "assert((Bm16::Slice1R<11U, 8U>(rinstr.high)) == 0b1111U);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "TRY_ASSIGN(imm32, Instr,Thumb::ThumbExpandImm((i<< 11U)| (imm3<<8U) | imm8));"
                    ]
                }
            },
            "post_block": [
                "if (n == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "cmn_immediate_t1": {
            "instruction": "cmn_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 4U>(rinstr.low)) == 0b010001U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);",
                "assert((Bm16::Slice1R<11U, 8U>(rinstr.high)) == 0b1111U);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "TRY_ASSIGN(imm32, Instr, Thumb::ThumbExpandImm((i << 11U)| (imm3 << 8U) | imm8));"
                    ]
                }
            },
            "post_block": [
                "if (n == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mov_immediate_t1": {
            "instruction": "mov_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b00100U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<10U, 8U>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "const u16 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.low);",
                        "const auto imm32_carry = ThumbImmediateResult{imm8, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk};"
                    ]
                }
            },
            "post_block": []
        },
        "mov_immediate_t2": {
            "instruction": "mov_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 5U>(rinstr.low)) == 0b00010U);",
                "assert((Bm16::Slice1R<3U, 0U>(rinstr.low)) == 0b1111U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "TRY_ASSIGN(imm32_carry, Instr,Thumb::ThumbExpandImm_C(imm12, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk));"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mov_immediate_t3": {
            "instruction": "mov_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 4U>(rinstr.low)) == 0b100100U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm4 = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const auto imm32_carry = ThumbImmediateResult{(imm4<<12U) | (i<< 11U) | (imm3<<8U) | imm8, false};"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mvn_immediate_t1": {
            "instruction": "mvn_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 5U>(rinstr.low)) == 0b00011U);",
                "assert((Bm16::Slice1R<3U, 0U>(rinstr.low)) == 0b1111U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "TRY_ASSIGN(imm32_carry, Instr,Thumb::ThumbExpandImm_C(imm12, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk));"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "tbb_h_t1": {
            "instruction": "tbb_h",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111010001101U);",
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.high)) == 0b11110000000U);"
            ],
            "def": {
                "tbh": {
                    "flag_decoder": [
                        "const u32 H = Bm16::IsolateBit<4U>(rinstr.high);",
                        "flags |= H << static_cast<InstrFlagsSet>(InstrFlagsShift::kTbhShift);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (n == 13U || m == 13U  || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if ( TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "rsb_immediate_t1": {
            "instruction": "rsb_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 6U>(rinstr.low)) == 0b0100001001U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm32 = 0x0U;"
                    ]
                }
            },
            "post_block": []
        },
        "rsb_immediate_t2": {
            "instruction": "rsb_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 5U>(rinstr.low)) == 0b01110U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "TRY_ASSIGN(imm32, Instr,Thumb::ThumbExpandImm(imm12));"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U || n == 13U ||  n == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mov_register_t1": {
            "instruction": "mov_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<11U, 8U>(rinstr.low)) == 0x6U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm32::Slice2R<7U, 7U, 2U, 0U>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<6U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if (d == 15U &&  TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mov_register_t2": {
            "instruction": "mov_register",
            "encoding": "t2",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 6U>(rinstr.low)) == 0b0000000000U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if ( TItOps::InITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mov_register_t3": {
            "instruction": "mov_register",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11101010010U);",
                "assert((Bm16::Slice1R<3U, 0U>(rinstr.low)) == 0b1111U);",
                "assert((Bm16::Slice1R<15U, 12U>(rinstr.high)) == 0b0000U);",
                "assert((Bm16::Slice1R<7U, 4U>(rinstr.high)) == 0b0000U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if ((flags& static_cast<InstrFlagsSet>(InstrFlags::kSetFlags) != 0U) && (d==13U || d==15U || m==13U || m==15U)) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if ((flags& static_cast<InstrFlagsSet>(InstrFlags::kSetFlags) == 0U) && (d==15U || m==15U || (d==13U && m==13U))) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "rrx_t1": {
            "instruction": "rrx",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11101010010U);",
                "assert((Bm16::Slice1R<3U, 0U>(rinstr.low)) == 0b1111U);",
                "assert((Bm16::Slice1R<15U, 12U>(rinstr.high)) == 0b0000U);",
                "assert((Bm16::Slice1R<7U, 4U>(rinstr.high)) == 0b0011U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if ((d == 13U) || (d == 15U) || (m == 13U) || (m == 15U)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldr_literal_t1": {
            "instruction": "ldr_literal",
            "encoding": "t1",
            "flags": [],
            "pre_block": [],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<10U, 8U>(rinstr.low);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u16 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8) << 2U;"
                    ]
                }
            }
        },
        "ldr_literal_t2": {
            "instruction": "ldr_literal",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 8U>(rinstr.low)) == 0b11111000U);",
                "assert((Bm16::Slice1R<6U, 0U>(rinstr.low)) == 0b1011111U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<7U>(rinstr.low);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "if (t == 15U &&  TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrb_immediate_t1": {
            "instruction": "ldrb_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b01111U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<10U, 6U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm5);"
                    ]
                }
            },
            "post_block": []
        },
        "ldrb_immediate_t2": {
            "instruction": "ldrb_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110001001U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "assert (Rt != 0b1111U);",
                "assert (Rn != 0b1111U);",
                "if (t == 13U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrb_immediate_t3": {
            "instruction": "ldrb_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110000001U);",
                "assert((Bm16::IsolateBit<11U>(rinstr.high)) == 0b1U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<9U>(rinstr.high);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = Bm16::IsolateBit<10U>(rinstr.high);",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<8U>(rinstr.high);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": [
                "assert ((Rt != 0b1111U) || (P!=1U) || (U!=0U) || (W!=0U));",
                "assert (Rn != 0b1111U);",
                "assert ((P != 0b1U) || (U != 0b1U) || (W != 0b0U));",
                "assert ((Rn != 0b1101U) || (P != 0x0U) || (U != 0x1U) || (W != 0x1U) || (imm8 != 0b00000100U) );",
                "if ((P == 0x0U) && (W == 0x0U) ) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 13U || (flags & static_cast<InstrFlagsSet>(InstrFlags::kWBack) && n == t)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (t == 15U && ((P == 0U)||(U == 1U)||(W == 1U))) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrsb_immediate_t1": {
            "instruction": "ldrsb_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110011001U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "assert (Rt != 0b1111U);",
                "assert (Rn != 0b1111U);",
                "if (t == 13U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrsb_immediate_t2": {
            "instruction": "ldrsb_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert(false); // not tested",
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110010001U);",
                "assert((Bm16::IsolateBit<11U>(rinstr.high)) == 0b1U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<9U>(rinstr.high);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = Bm16::IsolateBit<10U>(rinstr.high);",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<8U>(rinstr.high);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": [
                "assert ((Rt != 0b1111U) || (P!=1U) || (U!=0U) || (W!=0U));",
                "assert (Rn != 0b1111U);",
                "assert ((P != 0b1U) || (U != 0b1U) || (W != 0b0U));",
                "assert ((Rn != 0b1101U) || (P != 0x0U) || (U != 0x1U) || (W != 0x1U) || (imm8 != 0b00000100U) );",
                "if ((P == 0x0U) && (W == 0x0U) ) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 13U || (t == 15U && (W == 1U)) || (flags & static_cast<InstrFlagsSet>(InstrFlags::kWBack) && n == t)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrsh_immediate_t1": {
            "instruction": "ldrsh_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110011011U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "assert(Rn!=0b1111U);",
                "assert(Rt!=0b1111U);",
                "if (t == 13U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrsh_immediate_t2": {
            "instruction": "ldrsh_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110010011U);",
                "assert((Bm16::IsolateBit<11U>(rinstr.high)) == 0b1U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = static_cast<u32>(Bm16::IsolateBit<9U>(rinstr.high));",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = static_cast<u32>(Bm16::IsolateBit<10U>(rinstr.high));",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = static_cast<u32>(Bm16::IsolateBit<8U>(rinstr.high));",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = static_cast<u32>(Bm16::Slice1R<7U, 0U>(rinstr.high));",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": [
                "assert (Rn != 0b1111U);",
                "assert (Rt != 0b1111U || P != 1U || U != 0U || W != 0U);",
                "assert (P != 0b1U || U != 0b1U || W != 0b0U);",
                "if (P == 0b0U && W == 0b0U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 13U || (t == 15U && W == 1U) || (flags & static_cast<InstrFlagsSet>(InstrFlags::kWBack) && n == t)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrh_immediate_t1": {
            "instruction": "ldrh_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b10001U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<10U, 6U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm5<<1U);"
                    ]
                }
            },
            "post_block": []
        },
        "ldrh_immediate_t2": {
            "instruction": "ldrh_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110001011U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "assert (Rt != 0b1111U);",
                "assert (Rn != 0b1111U);",
                "if (t == 13U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrh_immediate_t3": {
            "instruction": "ldrh_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110000011U);",
                "assert((Bm16::IsolateBit<11U>(rinstr.high)) == 0b1U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = static_cast<u32>(Bm16::IsolateBit<9U>(rinstr.high));",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = static_cast<u32>(Bm16::IsolateBit<10U>(rinstr.high));",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = static_cast<u32>(Bm16::IsolateBit<8U>(rinstr.high));",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = static_cast<u32>(Bm16::Slice1R<7U, 0U>(rinstr.high));",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": [
                "assert (Rn != 0b1111U);",
                "assert (Rt != 0b1111U || P != 1U || U != 0U || W != 0U);",
                "assert (P != 0b1U || U != 0b1U || W != 0b0U);",
                "if (P == 0b0U && W == 0b0U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 13U || (t == 15U && W == 1U) || (flags & static_cast<InstrFlagsSet>(InstrFlags::kWBack) && n == t)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "pop_t1": {
            "instruction": "pop",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 9U>(rinstr.low)) == 0b1011110U);"
            ],
            "def": {
                "UnalignedAllow": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kUnalignedAllow);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u32 P = Bm16::IsolateBit<8U>(rinstr.low);",
                        "const u32 register_list = Bm16::Slice1R<7U, 0U>(rinstr.low);",
                        "const u32 registers = (P<<15U) | register_list;"
                    ]
                }
            },
            "post_block": [
                "if (Bm32::BitCount(registers) < 1U) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if ((Bm32::Slice1R<15U, 15U>(registers) == 0x1U) && ( TItOps::InITBlock(pstates)) && (! TItOps::LastInITBlock(pstates))) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "pop_t2": {
            "instruction": "pop",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 0U>(rinstr.low)) == 0b1110100010111101U);",
                "assert((Bm16::IsolateBit<13U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "UnalignedAllow": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kUnalignedAllow);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u32 P = Bm16::IsolateBit<15U>(rinstr.high);",
                        "const u32 M = Bm16::IsolateBit<14U>(rinstr.high);",
                        "const u32 register_list = Bm16::Slice1R<12U, 0U>(rinstr.high);",
                        "const u32 registers = (P<<15U) | (M<<14U) | register_list;"
                    ]
                }
            },
            "post_block": [
                "if ((Bm32::BitCount(registers) < 2U) || ((P == 1U) && M == 1U)) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if ((Bm32::Slice1R<15U, 15U>(registers) == 0x1U) && ( TItOps::InITBlock(pstates)) && (! TItOps::LastInITBlock(pstates))) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "pop_t3": {
            "instruction": "pop",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 0U>(rinstr.low)) == 0b1111100001011101U);",
                "assert((Bm16::Slice1R<11U, 0U>(rinstr.high)) == 0b101100000100U);"
            ],
            "def": {
                "UnalignedAllow": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kUnalignedAllow);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);",
                        "const u32 registers = 1U << Rt;"
                    ]
                }
            },
            "post_block": [
                "if (t == 13U || (t == 15U &&  TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates))) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldr_immediate_t1": {
            "instruction": "ldr_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b01101U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<10U, 6U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm5<<2U);"
                    ]
                }
            },
            "post_block": []
        },
        "ldr_immediate_t2": {
            "instruction": "ldr_immediate",
            "encoding": "t2",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b10011U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<10U, 8U>(rinstr.low);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u8 n = 13U;"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8 << 2U);"
                    ]
                }
            },
            "post_block": []
        },
        "ldr_immediate_t3": {
            "instruction": "ldr_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110001101U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "if (t == 15U &&  TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldr_immediate_t4": {
            "instruction": "ldr_immediate",
            "encoding": "t4",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110000101U);",
                "assert((Bm16::IsolateBit<11U>(rinstr.high)) == 0b1U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<9U>(rinstr.high);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = Bm16::IsolateBit<10U>(rinstr.high);",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<8U>(rinstr.high);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": [
                "assert (Rn != 0b1111U);",
                "assert ((P != 0b1U) || (U != 0b1U) || (W != 0b0U));",
                "if ((Rn == 0b1101U)  && (P == 0x0U) && (U == 0x1U) && (W == 0x1U) && (imm8 == 0b00000100U) ) {",
                "  // SEE POP",
                "  return PopT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}",
                "if ((P == 0x0U) && (W == 0x0U) ) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if ((flags & static_cast<InstrFlagsSet>(InstrFlags::kWBack) && n == t) || t == 15U &&  TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}"
            ]
        },
        "ldrex_t1": {
            "instruction": "ldrex",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111010000101U);",
                "assert((Bm16::Slice1R<11U, 8U>(rinstr.high)) == 0b1111U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": [
                "if (t == 13U || t == 15U || n == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}"
            ]
        },
        "ldrd_immediate_t1": {
            "instruction": "ldrd_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 9U>(rinstr.low)) == 0b1110100U);",
                "assert((Bm16::IsolateBit<6U>(rinstr.low)) == 0b1U);",
                "assert((Bm16::IsolateBit<4U>(rinstr.low)) == 0b1U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<7U>(rinstr.low);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = Bm16::IsolateBit<8U>(rinstr.low);",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<5U>(rinstr.low);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "t2": {
                    "decoder": [
                        "const u32 Rt2 = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 t2 = static_cast<u8>(Rt2);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8<<2U);"
                    ]
                }
            },
            "post_block": [
                "assert((P!=0U) || (W!=0));",
                "assert(Rn!=0b1111U);",
                "if (flags & static_cast<InstrFlagsSet>(InstrFlags::kWBack) && ((n == t) || (n == t2)) ) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (t == 13U || t == 15 || (t2 == 13U) || (t2 == 15)|| (t == t2)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "it_t1": {
            "instruction": "it",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<11U, 8U>(rinstr.low)) == 0xFu);"
            ],
            "def": {
                "firstcond": {
                    "decoder": [
                        "const u32 firstcond_32 = Bm16::Slice1R<7U, 4U>(rinstr.low);",
                        "const u8 firstcond = static_cast<u8>(firstcond_32);"
                    ]
                },
                "mask": {
                    "decoder": [
                        "const u32 mask_32 = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 mask = static_cast<u8>(mask_32);"
                    ]
                }
            },
            "post_block": [
                "assert(mask != 0x0U);",
                "if (firstcond == 0xFu || (firstcond == 0b1110U && Bm8::BitCount(mask) != 1U)) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "",
                "if ( TItOps::InITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "bl_t1": {
            "instruction": "bl",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 14U>(rinstr.high)) == 0x3U);",
                "assert((Bm16::IsolateBit<12U>(rinstr.high)) == 0x1U);",
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);"
            ],
            "def": {
                "imm32": {
                    "decoder": [
                        "const u32 s = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm10 = Bm16::Slice1R<9U, 0U>(rinstr.low);",
                        "const u32 j1 = Bm16::IsolateBit<13U>(rinstr.high); // bit 13",
                        "const u32 j2 = Bm16::IsolateBit<11U>(rinstr.high); // bit 11",
                        "const u32 imm11 = Bm16::Slice1R<10U, 0U>(rinstr.high); // bit 10..0",
                        "const u32 i1 = (~(j1 ^ s)) & 0x1U;",
                        "const u32 i2 = (~(j2 ^ s)) & 0x1U;",
                        "const u32 imm32_us = (s << 24U) | (i1 << 23U) | (i2 << 22U) | (imm10 << 12U) | imm11 << 1U;",
                        "const i32 imm32 = static_cast<int32_t>(Bm32::SignExtend<u32, 24U>(imm32_us));"
                    ]
                }
            },
            "post_block": [
                "if ( TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "bx_t1": {
            "instruction": "bx",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 7U>(rinstr.low) == 0b010001110U));"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<6U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if (TItOps::InITBlock(pstates) && (!TItOps::LastInITBlock(pstates))) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "blx_t1": {
            "instruction": "blx",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 7U>(rinstr.low) == 0b010001111U));"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<6U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if (m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if ( TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "b_t1": {
            "instruction": "b_cond",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "if ( TItOps::InITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ],
            "def": {
                "cond": {
                    "decoder": [
                        "const u32 cond_32 = Bm16::Slice1R<11U, 8U>(rinstr.low);",
                        "const u8 cond = static_cast<u8>(cond_32);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.low);",
                        "const i32 imm32 = Bm32::SignExtend<u32, 8U>(imm8 << 1U);"
                    ]
                }
            },
            "post_block": [
                "assert(cond!=0b1110U);",
                "assert(cond!=0b1111U);"
            ]
        },
        "b_t2": {
            "instruction": "b",
            "encoding": "t2",
            "flags": [],
            "pre_block": [],
            "def": {
                "imm32": {
                    "decoder": [
                        "const u32 imm_11_32 = Bm16::Slice1R<10U, 0U>(rinstr.low);",
                        "const i32 imm32 = Bm32::SignExtend<u32, 11U>((imm_11_32)<<1U);"
                    ]
                }
            },
            "post_block": [
                "if ( TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "b_t3": {
            "instruction": "b_cond",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<15U, 14U>(rinstr.high)) == 0b10U);",
                "assert((Bm16::IsolateBit<12U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "cond": {
                    "decoder": [
                        "const u32 cond_32 = Bm16::Slice1R<9U, 6U>(rinstr.low);",
                        "const u8 cond = static_cast<u8>(cond_32);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm11 = Bm16::Slice1R<10U, 0U>(rinstr.high);",
                        "const u32 imm6 = Bm16::Slice1R<5U, 0U>(rinstr.low);",
                        "const u32 J1 = Bm16::IsolateBit<13U>(rinstr.high); // bit 13",
                        "const u32 J2 = Bm16::IsolateBit<11U>(rinstr.high); // bit 11",
                        "const u32 S = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm32_us = (S << 20U) | (J2 << 19U) | (J1 << 18U) | (imm6 << 12U) | (imm11 << 1U);",
                        "const i32 imm32 = static_cast<int32_t>(Bm32::SignExtend<u32, 20U>(imm32_us));"
                    ]
                }
            },
            "post_block": [
                "if ( TItOps::InITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "b_t4": {
            "instruction": "b",
            "encoding": "t4",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<15U, 14U>(rinstr.high)) == 0b10U);",
                "assert((Bm16::IsolateBit<12U>(rinstr.high)) == 0b1U);"
            ],
            "def": {
                "imm32": {
                    "decoder": [
                        "const u32 imm11 = Bm16::Slice1R<10U, 0U>(rinstr.high);",
                        "const u32 imm10 = Bm16::Slice1R<9U, 0U>(rinstr.low);",
                        "const u32 J1 = Bm16::IsolateBit<13U>(rinstr.high); // bit 13",
                        "const u32 J2 = Bm16::IsolateBit<11U>(rinstr.high); // bit 11",
                        "const u32 S = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 I1 = (~(J1 ^ S)) & 0x1U;",
                        "const u32 I2 = (~(J2 ^ S)) & 0x1U;",
                        "const u32 imm32_us = (S << 24U) | (I1 << 23U) | (I2 << 22U) | (imm10 << 12U) | imm11 << 1U;",
                        "const i32 imm32 = static_cast<int32_t>(Bm32::SignExtend<u32, 24U>(imm32_us));"
                    ]
                }
            },
            "post_block": [
                "if ( TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sub_sp_minus_immediate_t1": {
            "instruction": "sub_sp_minus_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 7U>(rinstr.low)) == 0b101100001U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = 13U;"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm7 = Bm16::Slice1R<6U, 0U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm7<<2);"
                    ]
                }
            },
            "post_block": []
        },
        "sub_sp_minus_immediate_t2": {
            "instruction": "sub_sp_minus_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 5U>(rinstr.low)) == 0b01101U);",
                "assert((Bm16::Slice1R<3U, 0U>(rinstr.low)) == 0b1101U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "TRY_ASSIGN(imm32, Instr,Thumb::ThumbExpandImm(imm12));"
                    ]
                }
            },
            "post_block": [
                "assert( (d!=0b1111U) || (S!=1U) );",
                "if (d == 15U && (S == 0x0U)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sub_sp_minus_immediate_t3": {
            "instruction": "sub_sp_minus_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 0U>(rinstr.low)) == 0b1010101101U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "if (d == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sub_immediate_t1": {
            "instruction": "sub_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 9U>(rinstr.low)) == 0b0001111U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u8 n = static_cast<u8>(Bm16::Slice1R<5U, 3U>(rinstr.low));"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = static_cast<u8>(Bm16::Slice1R<2U, 0U>(rinstr.low));"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm3 = Bm16::Slice1R<8U, 6U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm3);"
                    ]
                }
            },
            "post_block": []
        },
        "sub_immediate_t2": {
            "instruction": "sub_immediate",
            "encoding": "t2",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b00111U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u8 n = static_cast<u8>(Bm16::Slice1R<10U, 8U>(rinstr.low));"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = static_cast<u8>(Bm16::Slice1R<10U, 8U>(rinstr.low));"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": []
        },
        "sub_immediate_t3": {
            "instruction": "sub_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 5U>(rinstr.low)) == 0b01101U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "TRY_ASSIGN(imm32, Instr,Thumb::ThumbExpandImm(imm12));"
                    ]
                }
            },
            "post_block": [
                "assert(!((d == 0xFu) && (S == 1U)) );",
                "if (n == 0b1101U ) {",
                "  return SubSpMinusImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}",
                "if (d == 13U || (d == 15U && S == 0x0U) || n == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sub_immediate_t4": {
            "instruction": "sub_immediate",
            "encoding": "t4",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 4U>(rinstr.low)) == 0b101010U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "assert(Rn != 0b1111U);",
                "if (Rn == 0b1101U) {",
                "    return SubSpMinusImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates); ",
                "}",
                "if (d == 13U || d == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sbc_immediate_t1": {
            "instruction": "sbc_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 5U>(rinstr.low)) == 0b01011U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "TRY_ASSIGN(imm32, Instr,Thumb::ThumbExpandImm(imm12)); "
                    ]
                }
            },
            "post_block": [
                "assert(!((d == 0xFu) && (S == 1U)) );",
                "assert(n!=0xDu );",
                "if (d == 13U || (d == 15U && S == 0x0U) || n == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "add_sp_plus_immediate_t1": {
            "instruction": "add_sp_plus_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b10101U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = static_cast<u8>(Bm16::Slice1R<10U, 8U>(rinstr.low));"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8<<2U);"
                    ]
                }
            },
            "post_block": []
        },
        "add_sp_plus_immediate_t2": {
            "instruction": "add_sp_plus_immediate",
            "encoding": "t2",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 7U>(rinstr.low)) == 0b101100000U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = 13U;"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm7 = Bm16::Slice1R<6U, 0U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm7<<2U);"
                    ]
                }
            },
            "post_block": []
        },
        "add_sp_plus_immediate_t3": {
            "instruction": "add_sp_plus_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 5U>(rinstr.low)) == 0b01000U);",
                "assert((Bm16::Slice1R<3U, 0U>(rinstr.low)) == 0b1101U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "TRY_ASSIGN(imm32, Instr,Thumb::ThumbExpandImm(imm12));"
                    ]
                }
            },
            "post_block": [
                "assert((Rd != 0b1111U) || (S != 1));",
                "if (d == 15U && S == 0x0U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "add_sp_plus_immediate_t4": {
            "instruction": "add_sp_plus_immediate",
            "encoding": "t4",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 0U>(rinstr.low)) == 0b1000001101U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "if (d == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "add_immediate_t1": {
            "instruction": "add_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 9U>(rinstr.low)) == 0b0001110U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u8 n = static_cast<u8>(Bm16::Slice1R<5U, 3U>(rinstr.low));"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = static_cast<u8>(Bm16::Slice1R<2U, 0U>(rinstr.low));"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm3 = Bm16::Slice1R<8U, 6U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm3);"
                    ]
                }
            },
            "post_block": []
        },
        "add_immediate_t2": {
            "instruction": "add_immediate",
            "encoding": "t2",
            "flags": [],
            "pre_block": [],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u8 n = static_cast<u8>(Bm16::Slice1R<10U, 8U>(rinstr.low));"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = static_cast<u8>(Bm16::Slice1R<10U, 8U>(rinstr.low));"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": []
        },
        "add_immediate_t3": {
            "instruction": "add_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 5U>(rinstr.low)) == 0b01000U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0x0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "TRY_ASSIGN(imm32, Instr,Thumb::ThumbExpandImm(imm12));"
                    ]
                }
            },
            "post_block": [
                "assert(!((d == 0xFu) && (S == 1U)) );",
                "if (Rn == 0b1101U) {",
                "    return AddSpPlusImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates); ",
                "}",
                "if (d == 13U || (d == 15U && S == 0x0U) || n == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "add_immediate_t4": {
            "instruction": "add_immediate",
            "encoding": "t4",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0x0U);",
                "assert((Bm16::Slice1R<9U, 5U>(rinstr.low)) == 0b10000U);",
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "assert(Rn != 0b1111U);",
                "if (Rn == 0b1101U) {",
                "    return AddSpPlusImmediateT4Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates); ",
                "}",
                "if (d == 13U || d == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "adc_immediate_t1": {
            "instruction": "adc_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 5U>(rinstr.low)) == 0b01010U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0x0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "TRY_ASSIGN(imm32, Instr,Thumb::ThumbExpandImm(imm12));"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U || n == 13U || n == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "tst_immediate_t1": {
            "instruction": "tst_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 4U>(rinstr.low)) == 0b000001U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);",
                "assert((Bm16::Slice1R<11U, 8U>(rinstr.high)) == 0b1111U);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "TRY_ASSIGN(imm32_carry, Instr,Thumb::ThumbExpandImm_C(imm12, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk));"
                    ]
                }
            },
            "post_block": [
                "if (n == 13U || n == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "teq_immediate_t1": {
            "instruction": "teq_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 4U>(rinstr.low)) == 0b001001U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);",
                "assert((Bm16::Slice1R<11U, 8U>(rinstr.high)) == 0b1111U);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "TRY_ASSIGN(imm32_carry, Instr,Thumb::ThumbExpandImm_C(imm12, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk));"
                    ]
                }
            },
            "post_block": [
                "if (n == 13U || n == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "tst_register_t1": {
            "instruction": "tst_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 6U>(rinstr.low)) == 0b0100001000U);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res = ImmShiftResults{SRType::SRType_LSL, 0U};"
                    ]
                }
            },
            "post_block": []
        },
        "teq_register_t1": {
            "instruction": "teq_register",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111010101001U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);",
                "assert((Bm16::Slice1R<11U, 8U>(rinstr.high)) == 0b1111U);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = static_cast<u32>(Bm16::Slice1R<5U, 4U>(rinstr.high));",
                        "const u32 imm2 = static_cast<u32>(Bm16::Slice1R<7U, 6U>(rinstr.high));",
                        "const u32 imm3 = static_cast<u32>(Bm16::Slice1R<14U, 12U>(rinstr.high));",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2) | imm2);"
                    ]
                }
            },
            "post_block": [
                "if (n == 13U || n == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "and_immediate_t1": {
            "instruction": "and_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);",
                "assert(((Bm16::Slice1R<11U, 8U>(rinstr.high)) != 0b1111U) || ((Bm16::IsolateBit<4U>(rinstr.low)) != 0b1U));",
                "assert((Bm16::Slice1R<9U, 5U>(rinstr.low)) == 0b00000U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "TRY_ASSIGN(imm32_carry, Instr,Thumb::ThumbExpandImm_C(imm12, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk));"
                    ]
                }
            },
            "post_block": [
                "if ( d == 13U || (d == 15U && S == 0U) || n == 13U || n == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "orr_immediate_t1": {
            "instruction": "orr_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 5U>(rinstr.low)) == 0b00010U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "TRY_ASSIGN(imm32_carry, Instr,Thumb::ThumbExpandImm_C(imm12, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk));"
                    ]
                }
            },
            "post_block": [
                "assert(Rn!=0b1111U);",
                "if ( d == 13U || d == 15U || n == 13U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "eor_immediate_t1": {
            "instruction": "eor_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11110U);",
                "assert((Bm16::Slice1R<9U, 5U>(rinstr.low)) == 0b00100U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "TRY_ASSIGN(imm32_carry, Instr,Thumb::ThumbExpandImm_C(imm12, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk));"
                    ]
                }
            },
            "post_block": [
                "if ( d == 13U || (d == 15U && (S == 0U)) || n == 13U || n == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sub_register_t1": {
            "instruction": "sub_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 9U>(rinstr.low)) == 0b0001101U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, 0U};"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u8 m = static_cast<u8>(Bm16::Slice1R<8U, 6U>(rinstr.low));"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u8 n = static_cast<u8>(Bm16::Slice1R<5U, 3U>(rinstr.low));"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = static_cast<u8>(Bm16::Slice1R<2U, 0U>(rinstr.low));"
                    ]
                }
            },
            "post_block": []
        },
        "sub_register_t2": {
            "instruction": "sub_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11101011101U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = static_cast<u32>(Bm16::IsolateBit<4U>(rinstr.low));",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = static_cast<u32>(Bm16::Slice1R<5U, 4U>(rinstr.high));",
                        "const u32 imm2 = static_cast<u32>(Bm16::Slice1R<7U, 6U>(rinstr.high));",
                        "const u32 imm3 = static_cast<u32>(Bm16::Slice1R<14U, 12U>(rinstr.high));",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2) | imm2);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                }
            },
            "post_block": [
                "assert((Rd != 0b1111U) || (S!=1U));",
                "assert(Rn != 0b1101U);",
                "if (d == 13U || (d == 15U && S == 0U) || n == 15U || m == 13U ||m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "rsb_register_t1": {
            "instruction": "rsb_register",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11101011110U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = static_cast<u32>(Bm16::IsolateBit<4U>(rinstr.low));",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = static_cast<u32>(Bm16::Slice1R<5U, 4U>(rinstr.high));",
                        "const u32 imm2 = static_cast<u32>(Bm16::Slice1R<7U, 6U>(rinstr.high));",
                        "const u32 imm3 = static_cast<u32>(Bm16::Slice1R<14U, 12U>(rinstr.high));",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2) | imm2);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U || n == 13U || n == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "umlal_t1": {
            "instruction": "umlal",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110111110U);",
                "assert((Bm16::Slice1R<7U, 4U>(rinstr.high)) == 0b0000U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "dHi": {
                    "decoder": [
                        "const u16 RdHi =  Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 dHi = static_cast<u8>(RdHi);"
                    ]
                },
                "dLo": {
                    "decoder": [
                        "const u16 RdLo = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 dLo = static_cast<u8>(RdLo);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (dLo == 13U || dLo == 15U || dHi == 13U || dHi == 15U || n == 13U || n == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (dHi == dLo) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "umull_t1": {
            "instruction": "umull",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110111010U);",
                "assert((Bm16::Slice1R<7U, 4U>(rinstr.high)) == 0b0000U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "dHi": {
                    "decoder": [
                        "const u16 RdHi =  Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 dHi = static_cast<u8>(RdHi);"
                    ]
                },
                "dLo": {
                    "decoder": [
                        "const u16 RdLo = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 dLo = static_cast<u8>(RdLo);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (dLo == 13U || dLo == 15U || dHi == 13U || dHi == 15U || n == 13U || n == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (dHi == dLo) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "smull_t1": {
            "instruction": "smull",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110111000U);",
                "assert((Bm16::Slice1R<7U, 4U>(rinstr.high)) == 0b0000U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "dHi": {
                    "decoder": [
                        "const u16 RdHi =  Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 dHi = static_cast<u8>(RdHi);"
                    ]
                },
                "dLo": {
                    "decoder": [
                        "const u16 RdLo = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 dLo = static_cast<u8>(RdLo);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (dHi == dLo) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mul_t2": {
            "instruction": "mul",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110110000U);",
                "assert((Bm16::Slice1R<15U, 12U>(rinstr.high)) == 0b1111U);",
                "assert((Bm16::Slice1R<7U, 4U>(rinstr.high)) == 0b0000U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U || n == 13U || n == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "udiv_t1": {
            "instruction": "udiv",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110111011U);",
                "assert((Bm16::Slice1R<15U, 12U>(rinstr.high)) == 0b1111U);",
                "assert((Bm16::Slice1R<7U, 4U>(rinstr.high)) == 0b1111U);"
            ],
            "def": {
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U || n == 13U || n == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sdiv_t1": {
            "instruction": "sdiv",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110111001U);",
                "assert((Bm16::Slice1R<15U, 12U>(rinstr.high)) == 0b1111U);",
                "assert((Bm16::Slice1R<7U, 4U>(rinstr.high)) == 0b1111U);"
            ],
            "def": {
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U || n == 13U || n == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mls_t1": {
            "instruction": "mls",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110110000U);",
                "assert((Bm16::Slice1R<7U, 4U>(rinstr.high)) == 0b0001U);"
            ],
            "def": {
                "a": {
                    "decoder": [
                        "const u16 Ra = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 a = static_cast<u8>(Ra);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U || n == 13U || n == 15U || m == 13U || m == 15U || (a == 13U) || (a == 15U)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mla_t1": {
            "instruction": "mla",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110110000U);",
                "assert((Bm16::Slice1R<7U, 4U>(rinstr.high)) == 0b0000U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "a": {
                    "decoder": [
                        "const u16 Ra = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 a = static_cast<u8>(Ra);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "assert(Ra!=0b1111U);",
                "if (d == 13U || d == 15U || n == 13U || n == 15U || m == 13U || m == 15U || (a == 13U) || (a == 15U)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "add_register_t1": {
            "instruction": "add_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 9U>(rinstr.low)) == 0b0001100U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, 0U};"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u8 m = static_cast<u8>(Bm16::Slice1R<8U, 6U>(rinstr.low));"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u8 n = static_cast<u8>(Bm16::Slice1R<5U, 3U>(rinstr.low));"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = static_cast<u8>(Bm16::Slice1R<2U, 0U>(rinstr.low));"
                    ]
                }
            },
            "post_block": []
        },
        "add_register_t2": {
            "instruction": "add_register",
            "encoding": "t2",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<10U, 8U>(rinstr.low)) == 0b100U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, 0U};"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u8 m = static_cast<u8>(Bm16::Slice1R<6U, 3U>(rinstr.low));"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u32 dn_1 = Bm16::IsolateBit<7U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(dn_1<<3U | Bm16::Slice1R<2U, 0U>(rinstr.low));"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u32 dn_2 = Bm16::IsolateBit<7U>(rinstr.low);",
                        "const u8 d = static_cast<u8>(dn_2<<3U | Bm16::Slice1R<2U, 0U>(rinstr.low));"
                    ]
                }
            },
            "post_block": [
                "assert(d != 0b1101U);",
                "assert(n != 0b1101U);",
                "if (d == 15U &&  TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (d == 15U && m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "add_register_t3": {
            "instruction": "add_register",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11101011000U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                        "const u32 imm2 = Bm16::Slice1R<7U, 6U>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2) | imm2);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                }
            },
            "post_block": [
                "assert((d != 0b1111U) || (S!=1U));",
                "assert(m != 0b1101U);",
                "if (d == 13U || (d == 15U && S == 0U) || n == 15U || m == 13U ||m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "adc_register_t1": {
            "instruction": "adc_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 6U>(rinstr.low)) == 0b0100000101U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res = ImmShiftResults{SRType::SRType_LSL, static_cast<u8>(0U)};"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                }
            },
            "post_block": []
        },
        "adc_register_t2": {
            "instruction": "adc_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11101011010U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                        "const u32 imm2 = Bm16::Slice1R<7U, 6U>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2) | imm2);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U || n == 13U || n == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "stmdb_t1": {
            "instruction": "stmdb",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert(false); // not implemented",
                "assert((Bm16::Slice1R<15U, 6U>(rinstr.low)) == 0b1110100100U);",
                "assert((Bm16::IsolateBit<4U>(rinstr.low)) == 0b0U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);",
                "assert((Bm16::IsolateBit<13U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<5U>(rinstr.low);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u32 M = Bm16::IsolateBit<14U>(rinstr.high);",
                        "const u32 register_list = Bm16::Slice1R<12U, 0U>(rinstr.high);",
                        "const u32 registers = (M<<14U) | register_list;"
                    ]
                }
            },
            "post_block": [
                "assert( (W != 0x1U) || (Rn != 0b1101U) );",
                "if (n == 15 || (Bm32::BitCount(registers) < 2U)) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                " // if wback && registers<n> == '1' then UNPREDICTABLE;"
            ]
        },
        "push_t1": {
            "instruction": "push",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<10U, 9U>(rinstr.low)) == 0b10U);"
            ],
            "def": {
                "UnalignedAllow": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kUnalignedAllow);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u32 M = Bm16::IsolateBit<8U>(rinstr.low);",
                        "const u32 register_list = Bm16::Slice1R<7U, 0U>(rinstr.low);",
                        "const u32 registers = (M<<14U) | register_list;"
                    ]
                }
            },
            "post_block": [
                "if (Bm32::BitCount(registers) < 1U) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "push_t2": {
            "instruction": "push",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 0U>(rinstr.low)) == 0b1110100100101101U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);",
                "assert((Bm16::IsolateBit<13U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "UnalignedAllow": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kUnalignedAllow);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u32 M = Bm16::IsolateBit<14U>(rinstr.high);",
                        "const u32 register_list = Bm16::Slice1R<12U, 0U>(rinstr.high);",
                        "const u32 registers = (M<<14U) | register_list;"
                    ]
                }
            },
            "post_block": [
                "if (Bm32::BitCount(registers) < 2U) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "push_t3": {
            "instruction": "push",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert(rinstr.low == 0b1111100001001101U);",
                "assert((Bm16::Slice1R<11U, 0U>(rinstr.high)) == 0b110100000100U);"
            ],
            "def": {
                "UnalignedAllow": {
                    "flag_decoder": [
                        "flags |=  static_cast<InstrFlagsSet>(InstrFlags::kUnalignedAllow);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);",
                        "const u32 registers = 1U << Rt;"
                    ]
                }
            },
            "post_block": [
                "if (t==13U || t==15U) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldm_t1": {
            "instruction": "ldm",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11001U);"
            ],
            "def": {
                "wback": {
                    "flag_decoder": [
                        "const u8 Rn_flag = static_cast<u8>(Bm16::Slice1R<10U, 8U>(rinstr.low));",
                        "const u16 register_list_flag = Bm16::Slice1R<7U, 0U>(rinstr.low);",
                        "const u16 n_mask = 1U << Rn_flag;",
                        "flags |= (register_list_flag&n_mask) == 0 ? static_cast<InstrFlagsSet>(InstrFlags::kWBack):0U;"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u16 register_list = Bm16::Slice1R<7U, 0U>(rinstr.low);",
                        "const u32 registers = static_cast<u32>(register_list);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<10U, 8U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (Bm32::BitCount(registers) < 1U) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldm_t2": {
            "instruction": "ldm",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 6U>(rinstr.low)) == 0b1110100010U);",
                "assert((Bm16::IsolateBit<4U>(rinstr.low)) == 0b1U);",
                "assert((Bm16::IsolateBit<13U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<5U>(rinstr.low);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u32 P = Bm16::IsolateBit<15U>(rinstr.high);",
                        "const u32 M = Bm16::IsolateBit<14U>(rinstr.high);",
                        "const u32 register_list = Bm16::Slice1R<12U, 0U>(rinstr.high);",
                        "const u32 registers = (P<<15U) | (M<<14U) | register_list;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "assert((W!=1) || (Rn!=0b1101U));",
                "if (n == 15 || (Bm32::BitCount(registers) < 2U) || ((P == 1U) && M == 1U)) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if ((Bm32::Slice1R<15U, 15U>(registers) == 0x1U) && ( TItOps::InITBlock(pstates)) && (! TItOps::LastInITBlock(pstates))) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (flags & static_cast<InstrFlagsSet>(InstrFlags::kWBack) && ( (registers &(1<<n)) != 0U)) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "stm_t1": {
            "instruction": "stm",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b11000U);"
            ],
            "def": {
                "wback": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u16 register_list = Bm16::Slice1R<7U, 0U>(rinstr.low);",
                        "const u32 registers =  static_cast<u32>(register_list);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<10U, 8U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": []
        },
        "stm_t2": {
            "instruction": "stm",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 6U>(rinstr.low)) == 0b1110100010U);",
                "assert((Bm16::IsolateBit<4U>(rinstr.low)) == 0b0U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);",
                "assert((Bm16::IsolateBit<13U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "UnalignedAllow": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kUnalignedAllow);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<5U>(rinstr.low);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u32 M = Bm16::IsolateBit<14U>(rinstr.high);",
                        "const u32 register_list = Bm16::Slice1R<12U, 0U>(rinstr.high);",
                        "const u32 registers = (M<<14U) | register_list;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (n == 15 || (Bm32::BitCount(registers) < 2U)){",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (flags&static_cast<InstrFlagsSet>(InstrFlags::kWBack) && ( (registers &(1<<n)) != 0U)) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sxth_t1": {
            "instruction": "sxth",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 6U>(rinstr.low)) == 0b1011001000U);"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "rotation": {
                    "decoder": [
                        "const u8 rotation = 0U;"
                    ]
                }
            },
            "post_block": []
        },
        "sxth_t2": {
            "instruction": "sxth",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 0U>(rinstr.low)) == 0b1111101000001111U);",
                "assert((Bm16::Slice1R<15U, 12U>(rinstr.high)) == 0b1111U);",
                "assert((Bm16::Slice1R<7U, 6U>(rinstr.high)) == 0b10U);"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "rotation": {
                    "decoder": [
                        "const u16 rotate = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                        "const u8 rotation = static_cast<u8>(rotate<<3U);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "uxtb_t1": {
            "instruction": "uxtb",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<11U, 6U>(rinstr.low)) == 0b001011U);"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "rotation": {
                    "decoder": [
                        "const u8 rotation = 0U;"
                    ]
                }
            },
            "post_block": []
        },
        "uxtb_t2": {
            "instruction": "uxtb",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 0U>(rinstr.low)) == 0b1111101001011111U);",
                "assert((Bm16::Slice1R<15U, 12U>(rinstr.high)) == 0b1111U);",
                "assert((Bm16::Slice1R<7U, 6U>(rinstr.high)) == 0b10U);"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "rotation": {
                    "decoder": [
                        "const u32 rotate = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                        "const u8 rotation = static_cast<u8>(rotate<<3U);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sxtb_t1": {
            "instruction": "sxtb",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 6U>(rinstr.low)) == 0b1011001001U);"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "rotation": {
                    "decoder": [
                        "const u8 rotation = 0U;"
                    ]
                }
            },
            "post_block": []
        },
        "sxtb_t2": {
            "instruction": "sxtb",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 0U>(rinstr.low)) == 0b1111101001001111U);",
                "assert((Bm16::Slice1R<15U, 12U>(rinstr.high)) == 0b1111U);",
                "assert((Bm16::Slice1R<7U, 6U>(rinstr.high)) == 0b10U);"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "rotation": {
                    "decoder": [
                        "const u16 rotate = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                        "const u8 rotation = static_cast<u8>(rotate<<3U);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "uxth_t1": {
            "instruction": "uxth",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 6U>(rinstr.low)) == 0b1011001010U);"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "rotation": {
                    "decoder": [
                        "const u8 rotation = 0U;"
                    ]
                }
            },
            "post_block": []
        },
        "uxth_t2": {
            "instruction": "uxth",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 0U>(rinstr.low)) == 0b1111101000011111U);",
                "assert((Bm16::Slice1R<15U, 12U>(rinstr.high)) == 0b1111U);",
                "assert((Bm16::Slice1R<7U, 6U>(rinstr.high)) == 0b10U);"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "rotation": {
                    "decoder": [
                        "const u32 rotate = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                        "const u8 rotation = rotate<<3U;"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "bfi_t1": {
            "instruction": "bfi",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111100110110U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);",
                "assert((Bm16::IsolateBit<5U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "lsbit": {
                    "decoder": [
                        "const u32 imm2 = static_cast<u32>(Bm16::Slice1R<7U, 6U>(rinstr.high));",
                        "const u32 imm3 = static_cast<u32>(Bm16::Slice1R<14U, 12U>(rinstr.high));",
                        "const u8 lsbit = static_cast<u8>((imm3<<2U)| imm2);"
                    ]
                },
                "msbit": {
                    "decoder": [
                        "const u16 msb = Bm16::Slice1R<4U, 0U>(rinstr.high);",
                        "const u8 msbit = static_cast<u8>(msb);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U || n == 13U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ubfx_t1": {
            "instruction": "ubfx",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111100111100U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);",
                "assert((Bm16::IsolateBit<5U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "lsbit": {
                    "decoder": [
                        "const u32 imm2 = Bm16::Slice1R<7U, 6U>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u8 lsbit = static_cast<u8>((imm3<<2U)| imm2);"
                    ]
                },
                "widthminus1": {
                    "decoder": [
                        "const u32 widthm1 = Bm16::Slice1R<4U, 0U>(rinstr.high);",
                        "const u8 widthminus1 = static_cast<u8>(widthm1);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U || n == 13U || n == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "eor_register_t1": {
            "instruction": "eor_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 6U>(rinstr.low)) == 0b0100000001U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "// TODO: use ImmShiftResults for all occureces",
                        "const auto shift_res = Alu32::DecodeImmShift(0b00, 0);"
                    ]
                }
            },
            "post_block": []
        },
        "eor_register_t2": {
            "instruction": "eor_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11101010100U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                        "const u32 imm2 = Bm16::Slice1R<7U, 6U>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2U) | imm2);"
                    ]
                }
            },
            "post_block": [
                "assert((Rd!=0b1111U) || (S!=1));",
                "if (d == 13U || (d == 15U && (S == 0)) || n == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sbc_register_t2": {
            "instruction": "sbc_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11101011011U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                        "const u32 imm2 = Bm16::Slice1R<7U, 6U>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2U) | imm2);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U ||n == 13U || n == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "orr_register_t1": {
            "instruction": "orr_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 6U>(rinstr.low)) == 0b0100001100U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res = Alu32::DecodeImmShift(0b00, 0);"
                    ]
                }
            },
            "post_block": []
        },
        "orr_register_t2": {
            "instruction": "orr_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11101010010U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                        "const u32 imm2 = Bm16::Slice1R<7U, 6U>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2U) | imm2);"
                    ]
                }
            },
            "post_block": [
                "assert(Rn!=0b1111U);",
                "if (d == 13U || d == 15U || n == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "and_register_t1": {
            "instruction": "and_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 6U>(rinstr.low)) == 0b0100000000U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res = Alu32::DecodeImmShift(0b00, 0);"
                    ]
                }
            },
            "post_block": []
        },
        "and_register_t2": {
            "instruction": "and_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11101010000U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                        "const u32 imm2 = Bm16::Slice1R<7U, 6U>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2U) | imm2);"
                    ]
                }
            },
            "post_block": [
                "assert((Rd!=0b1111U) || (S!=0b1U));",
                "if (d == 13U || (d == 15U && (S == 0U)) || n == 13U || n == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "bic_immediate_t1": {
            "instruction": "bic_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<9U, 5U>(rinstr.low)) == 0b00001U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10U>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm12 = (i << 11U) | (imm3 << 8U) | imm8;",
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "TRY_ASSIGN(imm32_carry, Instr,Thumb::ThumbExpandImm_C(imm12, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk));"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U || n == 13U|| n == 15U){",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "bic_register_t1": {
            "instruction": "bic_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 6U>(rinstr.low)) == 0b0100001110U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, 0U};"
                    ]
                }
            },
            "post_block": []
        },
        "bic_register_t2": {
            "instruction": "bic_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11101010001U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                        "const u32 imm2 = Bm16::Slice1R<7U, 6U>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2U) | imm2);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U || n == 13U || n == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "lsr_register_t1": {
            "instruction": "lsr_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 6U>(rinstr.low)) == 0b0100000011U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": []
        },
        "lsr_register_t2": {
            "instruction": "lsr_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11111010001U);",
                "assert((Bm16::Slice1R<15U, 12U>(rinstr.high)) == 0b1111U);",
                "assert((Bm16::Slice1R<7U, 4U>(rinstr.high)) == 0b0000U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15 || n == 13U || n == 15 || m == 13U || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "asr_register_t1": {
            "instruction": "asr_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 6U>(rinstr.low)) == 0b0100000100U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": []
        },
        "asr_register_t2": {
            "instruction": "asr_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11111010010U);",
                "assert((Bm16::Slice1R<15U, 12U>(rinstr.high)) == 0b1111U);",
                "assert((Bm16::Slice1R<7U, 4U>(rinstr.high)) == 0b0000U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15 || n == 13U || n == 15 || m == 13U || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "lsr_immediate_t1": {
            "instruction": "lsr_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b00001U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0U;"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<10U, 6U>(rinstr.low);",
                        "const auto shift_res = Alu32::DecodeImmShift(0b01U, imm5);"
                    ]
                }
            },
            "post_block": []
        },
        "lsr_immediate_t2": {
            "instruction": "lsr_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11101010010U);",
                "assert((Bm16::Slice1R<3U, 0U>(rinstr.low)) == 0b1111U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);",
                "assert((Bm16::Slice1R<5U, 4U>(rinstr.high)) == 0b01U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm3_32 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm2_32 = Bm16::Slice1R<7U, 6U>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(0b01U, (imm3_32<<2U) | imm2_32);"
                    ]
                }
            },
            "post_block": [
                "assert(shift_res.type == SRType::SRType_LSR);",
                "if (d == 13U || d == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mvn_register_t2": {
            "instruction": "mvn_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11101010011U);",
                "assert((Bm16::Slice1R<3U, 0U>(rinstr.low)) == 0b1111U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm3 = static_cast<u32>(Bm16::Slice1R<14U, 12U>(rinstr.high));",
                        "const u32 imm2 = static_cast<u32>(Bm16::Slice1R<7U, 6U>(rinstr.high));",
                        "const u32 type = static_cast<u32>(Bm16::Slice1R<5U, 4U>(rinstr.high));",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2U) | imm2);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13U || d == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "asr_immediate_t2": {
            "instruction": "asr_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 5U>(rinstr.low)) == 0b11101010010U);",
                "assert((Bm16::Slice1R<3U, 0U>(rinstr.low)) == 0b1111U);",
                "assert((Bm16::IsolateBit<15U>(rinstr.high)) == 0b0U);",
                "assert((Bm16::Slice1R<5U, 4U>(rinstr.high)) == 0b10U);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4U>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm3_32 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                        "const u32 imm2_32 = Bm16::Slice1R<7U, 6U>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(0b10U, (imm3_32<<2U) | imm2_32);"
                    ]
                }
            },
            "post_block": [
                "assert(shift_res.type == SRType::SRType_ASR);",
                "if (d == 13U || d == 15U || m == 13U || m == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "str_register_t1": {
            "instruction": "str_register",
            "encoding": "t1",
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 9U>(rinstr.low)) == 0b0101000U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<8U, 6U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res = ImmShiftResults{SRType::SRType_LSL, 0U};"
                    ]
                }
            },
            "post_block": []
        },
        "str_register_t2": {
            "instruction": "str_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110000100U);",
                "assert((Bm16::Slice1R<11U, 6U>(rinstr.high)) == 0b000000U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm2 = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, static_cast<u8>(imm2)};"
                    ]
                }
            },
            "post_block": [
                "if (t == 15U || m == 13U || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "strb_register_t1": {
            "instruction": "strb_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 9U>(rinstr.low)) == 0b0101010U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<8U, 6U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res = ImmShiftResults{SRType::SRType_LSL, 0U};"
                    ]
                }
            },
            "post_block": []
        },
        "strb_register_t2": {
            "instruction": "strb_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110000000U);",
                "assert((Bm16::Slice1R<11U, 6U>(rinstr.high)) == 0b000000U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm2 = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, static_cast<u8>(imm2)};"
                    ]
                }
            },
            "post_block": [
                "if (Rn == 0b1111U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 13U || t == 15U || m == 13U || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "strh_register_t2": {
            "instruction": "strh_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110000010U);",
                "assert((Bm16::Slice1R<11U, 6U>(rinstr.high)) == 0b000000U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm2 = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, static_cast<u8>(imm2)};"
                    ]
                }
            },
            "post_block": [
                "if (Rn == 0b1111U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 13U || t == 15U || m == 13U || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrb_register_t1": {
            "instruction": "ldrb_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 9U>(rinstr.low)) == 0b0101110U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<8U, 6U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, 0x0U};"
                    ]
                }
            },
            "post_block": []
        },
        "ldr_register_t1": {
            "instruction": "ldr_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 9U>(rinstr.low)) == 0b0101100U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<8U, 6U>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res = ImmShiftResults{SRType::SRType_LSL, 0x0U};"
                    ]
                }
            },
            "post_block": []
        },
        "ldr_register_t2": {
            "instruction": "ldr_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110000101U);",
                "assert((Bm16::Slice1R<11U, 6U>(rinstr.high)) == 0b000000U);",
                "assert((Bm16::Slice1R<3U, 0U>(rinstr.low)) != 0b1111U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm2 = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, static_cast<u8>(imm2)};"
                    ]
                }
            },
            "post_block": [
                "if (m == 13U || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (t == 15U &&  TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrh_register_t2": {
            "instruction": "ldrh_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110000011U);",
                "assert((Bm16::Slice1R<11U, 6U>(rinstr.high)) == 0b000000U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm2 = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, static_cast<u8>(imm2)};"
                    ]
                }
            },
            "post_block": [
                "assert(Rn!=0b1111U);",
                "assert(Rt!=0b1111U);",
                "if (t == 13U || m == 13U || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "strd_immediate_t1": {
            "instruction": "strd_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 9U>(rinstr.low)) == 0b1110100U);",
                "assert((Bm16::IsolateBit<6U>(rinstr.low)) == 0b1U);",
                "assert((Bm16::IsolateBit<4U>(rinstr.low)) == 0b0U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<7U>(rinstr.low);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = Bm16::IsolateBit<8U>(rinstr.low);",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<5U>(rinstr.low);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "t2": {
                    "decoder": [
                        "const u16 Rt2 = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 t2 = static_cast<u8>(Rt2);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8_32 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8_32<<2U);"
                    ]
                }
            },
            "post_block": [
                "assert((P!=0U) || (W!=0U));",
                "if (flags&static_cast<InstrFlagsSet>(InstrFlags::kWBack) && (n == t || n == t2)) { ",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (n == 15U ||t == 13U || t == 15U || t2 == 13U || t2 == 15U) { ",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "strh_immediate_t1": {
            "instruction": "strh_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b10000U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<10U, 6U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm5<<1U);"
                    ]
                }
            },
            "post_block": []
        },
        "strh_immediate_t2": {
            "instruction": "strh_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110001010U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "if (t == 13U || t == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "strh_immediate_t3": {
            "instruction": "strh_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110000010U);",
                "assert((Bm16::IsolateBit<11U>(rinstr.high)) == 0b1U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<9U>(rinstr.high);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = Bm16::IsolateBit<10U>(rinstr.high);",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<8U>(rinstr.high);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": [
                "assert (P!=0b1U || U!=0b1U || W!=0b0U);",
                "if ((Rn == 0b1111U) || (P == 0b0 && W == 0b0U) ) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if ((t == 13U || t == 15U) && (flags&static_cast<InstrFlagsSet>(InstrFlags::kWBack) && n == t)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "strb_immediate_t1": {
            "instruction": "strb_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b01110U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<10U, 6U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm5);"
                    ]
                }
            },
            "post_block": []
        },
        "strb_immediate_t2": {
            "instruction": "strb_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110001000U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "if (Rn == 0b1111U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 13U || t == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "strb_immediate_t3": {
            "instruction": "strb_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110000000U);",
                "assert((Bm16::IsolateBit<11U>(rinstr.high)) == 0b1U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<9U>(rinstr.high);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = Bm16::IsolateBit<10U>(rinstr.high);",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<8U>(rinstr.high);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": [
                "assert((P!=1U) ||(U!=1) || (W!=0U)) ;",
                "if (n == 15U || ((P == 0U) && (W == 0U))) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 13U || t == 15U || (flags&static_cast<InstrFlagsSet>(InstrFlags::kWBack) && n == t)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "str_immediate_t1": {
            "instruction": "str_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b01100U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5U, 3U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<10U, 6U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm5<<2);"
                    ]
                }
            },
            "post_block": []
        },
        "str_immediate_t2": {
            "instruction": "str_immediate",
            "encoding": "t2",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 11U>(rinstr.low)) == 0b10010U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u8 n = 13U;"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<10U, 8U>(rinstr.low);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8<<2U);"
                    ]
                }
            },
            "post_block": []
        },
        "str_immediate_t3": {
            "instruction": "str_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110001100U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "if (n == 0b1111U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 15U) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "str_immediate_t4": {
            "instruction": "str_immediate",
            "encoding": "t4",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111110000100U);",
                "assert((Bm16::IsolateBit<11U>(rinstr.high)) == 0b1U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<9U>(rinstr.high);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = Bm16::IsolateBit<10U>(rinstr.high);",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<8U>(rinstr.high);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8_32 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8_32);"
                    ]
                }
            },
            "post_block": [
                "assert((P!=1U) ||(U!=1) || (W!=0U)) ;",
                "if ((n==13U) && (P==1) && (U==0U) && (W==1U) && (imm8_32==0b00000100U)) {",
                "  return PushT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}",
                "if (n == 15U || ((P == 0U) && (W == 0U))) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 15U || (flags&static_cast<InstrFlagsSet>(InstrFlags::kWBack) && n == t)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "strex_t1": {
            "instruction": "strex",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111010000100U);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8_32 = Bm16::Slice1R<7U, 0U>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8_32);"
                    ]
                }
            },
            "post_block": [
                "if (d == n || d == t) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "cb_n_z_t1": {
            "instruction": "cb_n_z",
            "encoding": "t1",
            "flags": [],
            "pattern": {
                "lo": "1011x0xxxxxxxxxx",
                "hi": "0xxxxxxxxxxxxxxx"
            },
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 12U>(rinstr.low)) == 0b1011U);",
                "assert((Bm16::IsolateBit<10U>(rinstr.low)) == 0b0U);",
                "assert((Bm16::IsolateBit<8U>(rinstr.low)) == 0b1U);"
            ],
            "def": {
                "nonzero": {
                    "flag_decoder": [
                        "const u32 op = Bm16::IsolateBit<11U>(rinstr.low);",
                        "flags |= op << static_cast<InstrFlagsSet>(InstrFlagsShift::kNonZeroShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2U, 0U>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<7U, 3U>(rinstr.low);",
                        "const u32 i = Bm16::IsolateBit<9U>(rinstr.low);",
                        "const i32 imm32 = Bm32::ZeroExtend<u32>((i<<6U) | (imm5<<1U));"
                    ]
                }
            },
            "post_block": [
                "if ( TItOps::InITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "svc_t1": {
            "instruction": "svc",
            "encoding": "t1",
            "flags": [],
            "pattern": {
                "lo": "11011111xxxxxxxx"
            },
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 8U>(rinstr.low)) == 0b11011111U);"
            ],
            "def": {
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": []
        },
        "bkpt_t1": {
            "instruction": "bkpt",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 8U>(rinstr.low)) == 0b10111110U);"
            ],
            "def": {
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7U, 0U>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": []
        },
        "msr_t1": {
            "instruction": "msr",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 4U>(rinstr.low)) == 0b111100111000U);",
                "assert((Bm16::Slice1R<15U, 12U>(rinstr.high)) == 0b1000U);",
                "assert((Bm16::Slice1R<9U, 8U>(rinstr.high)) == 0b00U);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u8 n = static_cast<u8>(Bm16::Slice1R<3U, 0U>(rinstr.low));"
                    ]
                },
                "mask": {
                    "decoder": [
                        "const u8 mask = static_cast<u8>(Bm16::Slice1R<11U, 10U>(rinstr.high));"
                    ]
                },
                "SYSm": {
                    "decoder": [
                        "const u8 SYSm = static_cast<u8>(Bm16::Slice1R<7U, 0U>(rinstr.high));"
                    ]
                }
            },
            "post_block": [
                "if (mask == 0b00U || (mask != 0b10U && !(SYSm == 0U || SYSm==1U || SYSm==2U || SYSm==3U))) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if ((n==13U) || (n==15U) || !(SYSm == 0U || SYSm==1U || SYSm==2U || SYSm==3U || SYSm==5U || SYSm==6U || SYSm==7U || SYSm==8U || SYSm==9U || SYSm==16U || SYSm==17U || SYSm==18U || SYSm==19U || SYSm==20U)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mrs_t1": {
            "instruction": "mrs",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert(rinstr.low == 0b1111001111101111U);",
                "assert((Bm16::Slice1R<15U, 12U>(rinstr.high)) == 0b1000U);"
            ],
            "def": {
                "d": {
                    "decoder": [
                        "const u8 d = static_cast<u8>(Bm16::Slice1R<11U, 8U>(rinstr.high));"
                    ]
                },
                "mask": {
                    "decoder": [
                        "const u8 mask = static_cast<u8>(Bm16::Slice1R<11U, 10U>(rinstr.high));"
                    ]
                },
                "SYSm": {
                    "decoder": [
                        "const u8 SYSm = static_cast<u8>(Bm16::Slice1R<7U, 0U>(rinstr.high));"
                    ]
                }
            },
            "post_block": [
                "if ((d==13U) || (d==15U) || !(SYSm == 0U || SYSm==1U || SYSm==2U || SYSm==3U || SYSm==5U || SYSm==6U || SYSm==7U || SYSm==8U || SYSm==9U || SYSm==16U || SYSm==17U || SYSm==18U || SYSm==19U || SYSm==20U)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        }
    },
    "splitters": {
        "16bit_op00000": {
            "flags": [],
            "splitters": [
                "// # 16-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p129",
                "// ",
                "// # Shift (immediate), add, subtract, move, and compare",
                "const u16 opcode = Bm16::Slice1R<13U, 9U>(rinstr.low);",
                "if (Bm16::Slice1R<4U, 2U>(opcode) == 0b000U) {",
                "  if (Bm16::Slice1R<10U, 6U>(rinstr.low) == 0b00000U) {",
                "    return MovRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else {",
                "    return LslImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "}"
            ]
        },
        "16bit_op00011": {
            "flags": [],
            "splitters": [
                "// # 16-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p129",
                "// ",
                "// # Shift (immediate), add, subtract, move, and compare",
                "//  see Armv7-M Architecture Reference Manual Issue E.e p130",
                "const u16 opcode = Bm16::Slice1R<13U, 9U>(rinstr.low);",
                "if (opcode == 0b01100U) {",
                "  return AddRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}  else if (opcode == 0b01110U) {",
                "  return AddImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (opcode == 0b01101U) {",
                "  return SubRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (opcode == 0b01111U) {",
                "  return SubImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}"
            ]
        },
        "16bit_op01010": {
            "flags": [],
            "splitters": [
                "// # Load/store single data item",
                "// see Armv7-M Architecture Reference Manual Issue E.e p133",
                "// ",
                "const u16 op_a = Bm16::Slice1R<15U, 12U>(rinstr.low);",
                "const u16 op_b = Bm16::Slice1R<11U, 9U>(rinstr.low);",
                "if (op_a == 0b0101U && op_b == 0b000U) {",
                "   return StrRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (op_a == 0b0101U && op_b == 0b010U) {",
                "  return StrbRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}"
            ]
        },
        "16bit_op10111": {
            "flags": [],
            "splitters": [
                "// # Miscellaneous 16-bit instructions",
                "// see Armv7-M Architecture Reference Manual Issue E.e p134",
                "// ",
                "const u16 opcode = Bm16::Slice1R<11U, 5U>(rinstr.low);",
                "if (Bm16::Slice1R<6U, 3U>(opcode) == 0b1001U) {",
                "  return CbNZT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6U, 3U>(opcode) == 0b1011U) {",
                "  return CbNZT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6U, 4U>(opcode) == 0b110U) {",
                "  return PopT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6U, 3U>(opcode) == 0b1110U) {",
                "  return BkptT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6U, 3U>(opcode) == 0b1111U) {",
                "  // # If-Then, and hints",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p135",
                "  if (Bm16::Slice1R<3U, 0U>(rinstr.low) != 0x0U) {",
                "    return ItT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "  if ( (Bm16::Slice1R<3U, 0U>(rinstr.low) == 0x0U) && (Bm16::Slice1R<7U, 4U>(rinstr.low) == 0x0U)) {",
                "    return NopT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "}"
            ]
        },
        "16bit_op10110": {
            "flags": [],
            "splitters": [
                "// # 16-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p129",
                "// ",
                "// ## Miscellaneous 16-bit instructions",
                "// see Armv7-M Architecture Reference Manual Issue E.e p134",
                "const u16 opcode = Bm16::Slice1R<11U, 5U>(rinstr.low);",
                "if (Bm16::Slice1R<6U, 2U>(opcode) == 0b00000U) {",
                "   return AddSpPlusImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6U, 3U>(opcode) == 0b0001U) {",
                "   return CbNZT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6U, 2U>(opcode) == 0b00001U) {",
                "   return SubSpMinusImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6U, 3U>(opcode) == 0b0011U) {",
                "  return CbNZT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6U, 1U>(opcode) == 0b001001U) {",
                "  return SxtbT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6U, 1U>(opcode) == 0b001011U) {",
                "  return UxtbT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6U, 1U>(opcode) == 0b001010U) {",
                "    return UxthT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6U, 1U>(opcode) == 0b001000U) {",
                "    return SxthT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6U, 4U>(opcode) == 0b010U) {",
                "    return PushT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}"
            ]
        },
        "16bit_op01000": {
            "flags": [],
            "splitters": [
                "if (Bm16::IsolateBit<10U>(rinstr.low) == 0x1) {",
                "  // ## Special data instructions and branch and exchange",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p132",
                "  if (Bm16::Slice1R<9U, 8U>(rinstr.low) == 0b00U) {",
                "    return AddRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (Bm16::Slice1R<9U, 8U>(rinstr.low) == 0b10U) {",
                "    return MovRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (Bm16::Slice1R<9U, 8U>(rinstr.low) == 0b01U) {",
                "    return CmpRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (Bm16::Slice1R<9U, 7U>(rinstr.low) == 0b110U) {",
                "    return BxT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (Bm16::Slice1R<9U, 7U>(rinstr.low) == 0b111U) {",
                "    return BlxT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "} else {",
                "  // ## Data processing",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p131",
                "  const u16 _opcode = Bm16::Slice1R<9U, 6U>(rinstr.low);",
                "  if (_opcode == 0b0000U) {",
                "    return AndRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b0010U) {",
                "    return LslRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b0011U) {",
                "    return LsrRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b0100U) {",
                "    return AsrRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b0101U) {",
                "    return AdcRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b0001U) {",
                "    return EorRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b1000U) {",
                "    return TstRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b1001U) {",
                "    return RsbImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b1010U) {",
                "    return CmpRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b1100U) {",
                "    return OrrRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b1110U) {",
                "    return BicRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "}"
            ]
        },
        "16bit_op01011": {
            "flags": [],
            "splitters": [
                "// # 16-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p129",
                "",
                "const u16 opB = Bm16::Slice1R<11U, 9U>(rinstr.low);",
                "// # Load/store single data item",
                "// see Armv7-M Architecture Reference Manual Issue E.e p133",
                "if (opB == 0b100U) {",
                "  return LdrRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (opB == 0b110U) {",
                "  return LdrbRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}"
            ]
        },
        "16bit_op01101": {
            "flags": [],
            "splitters": [
                "// # 16-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p129",
                "",
                "const u16 opB = Bm16::Slice1R<11U, 9U>(rinstr.low);",
                "// # Load/store single data item",
                "// see Armv7-M Architecture Reference Manual Issue E.e p133",
                "if (Bm16::Slice1R<2U, 2U>(opB) == 0b1U) {",
                "  return LdrImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}"
            ]
        },
        "16bit_op11011": {
            "flags": [],
            "splitters": [
                "// # 16-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p129",
                "// ",
                "// ## Conditional branch, and Supervisor Call",
                "// see Armv7-M Architecture Reference Manual Issue E.e p136",
                "const u16 opcode = Bm16::Slice1R<11U, 8U>(rinstr.low);",
                "if (Bm16::Slice1R<3U, 1U>(opcode) != 0b111U) {",
                "  return BT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (opcode == 0b1111U) {",
                "  return SvcT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}"
            ]
        },
        "32bit_op11101": {
            "flags": [
                "32bit"
            ],
            "splitters": [
                "// # 32-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p137",
                "if (Bm16::Slice1R<10U, 9U>(rinstr.low) == 0b01U) {",
                "  // ## Data processing (shifted register)",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p150",
                "  const u16 op = Bm16::Slice1R<8U, 5U>(rinstr.low);",
                "  const u16 Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                "  const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                "  const u16 S = Bm16::IsolateBit<4U>(rinstr.low);",
                "  if ((op == 0b0000U) && (Rd != 0b1111U)) {",
                "    return AndRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b0001U)   {",
                "    return BicRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b0011U && Rn == 0b1111U) {",
                "    return MvnRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b1000U && Rd != 0b1111U) {",
                "    return AddRegisterT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b1110U) {",
                "    return RsbRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b0010U && Rn == 0b1111U) {",
                "    // ### Move register and immediate shifts",
                "    // see Armv7-M Architecture Reference Manual Issue E.e p151",
                "    const u32 type = static_cast<u32>(Bm16::Slice1R<5U, 4U>(rinstr.high));",
                "    const u32 imm2 = static_cast<u32>(Bm16::Slice1R<7U, 6U>(rinstr.high));",
                "    const u32 imm3 = static_cast<u32>(Bm16::Slice1R<14U, 12U>(rinstr.high));",
                "    const u32 imm3_2 = imm3<<2U | imm2;",
                "    if (type == 0b00U && imm3_2==0b00000U) {",
                "      return MovRegisterT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "    } else if (type == 0b01U) {",
                "      return LsrImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "    } else if (type == 0b10U) {",
                "      return AsrImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "    } else if (type == 0b00U && imm3_2!=0b00000U) {",
                "      return LslImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "    } else if (type == 0b11U && imm3_2==0b00000U) {",
                "      return RrxT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "    }",
                "  } else if (op == 0b0010U && Rn != 0b1111U) {",
                "    return OrrRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b0100U && Rd != 0b1111U) {",
                "    return EorRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b0100U && Rd == 0b1111U && S==1) {",
                "    return TeqRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b0100U && Rd == 0b1111U && S==0) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "  } else if (op == 0b1101U && Rd != 0b1111U) {",
                "   return SubRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b1010U) {",
                "   return AdcRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b1011U) {",
                "   return SbcRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b1101U && Rd == 0b1111U) {",
                "   return CmpRegisterT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "} else if ((Bm16::Slice1R<10U, 9U>(rinstr.low) == 0b00U) && (Bm16::IsolateBit<6U>(rinstr.low) == 0b0U)) {",
                "  // ## Load Multiple and Store Multiple",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p144",
                "  const u16 op = Bm16::Slice1R<8U, 7U>(rinstr.low);",
                "  const u16 W = Bm16::IsolateBit<5U>(rinstr.low);",
                "  const u16 Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                "  const u16 L = Bm16::IsolateBit<4U>(rinstr.low);",
                "  const u16 W_Rn = (W<<4U) | Rn;",
                "  if ((op == 0b10U) && (L == 0U) && (W_Rn == 0b11101U)){ ",
                "    return PushT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((op == 0b01U) && (L == 0U) ){ ",
                "    return StmT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((op == 0b10U) && (L == 0U) && (W_Rn != 0b11101U)){ ",
                "    return StmdbT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ( (op == 0b01U) && (L == 1U) && (W_Rn != 0b11101U)) { ",
                "    return LdmT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ( (op == 0b01U) && (L == 1U) && (W_Rn == 0b11101U)) { ",
                "    return PopT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "} else if ((Bm16::Slice1R<10U, 9U>(rinstr.low) == 0b00U) && (Bm16::IsolateBit<6U>(rinstr.low) == 0b1U)) {",
                "  // ## Load/store dual or exclusive, table branch",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p145",
                "  const u16 op1 = Bm16::Slice1R<8U, 7U>(rinstr.low);",
                "  const u16 op2 = Bm16::Slice1R<5U, 4U>(rinstr.low);",
                "  const u16 op3 = Bm16::Slice1R<7U, 4U>(rinstr.high);",
                "  if (op1 == 0b00U && op2 == 0b00U) {",
                "    return StrexT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op1 == 0b00U && op2 == 0b01U) {",
                "    return LdrexT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<1U, 1U>(op1) == 0b0U) && (op2 == 0b10U)) {",
                "    return StrdImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<1U, 1U>(op1) == 0b1U) && (Bm16::Slice1R<0U, 0U>(op2) == 0b0U)) {",
                "    return StrdImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<1U, 1U>(op1) == 0b0U) && (op2 == 0b11U)) {",
                "    return LdrdImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<1U, 1U>(op1) == 0b1U) && (Bm16::Slice1R<0U, 0U>(op2) == 0b1U)) {",
                "    return LdrdImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((op1 == 0b01U) && (op2 == 0b01U) && (op3 == 0b0000U)) {",
                "    return TbbHT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((op1 == 0b01U) && (op2 == 0b01U) && (op3 == 0b0001U)) {",
                "    return TbbHT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "}"
            ]
        },
        "32bit_op11110": {
            "flags": [
                "32bit"
            ],
            "splitters": [
                "// # 32-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p137",
                "const u16 op1 = Bm16::Slice1R<12U, 11U>(rinstr.low);",
                "const u16 op2 = Bm16::Slice1R<10U, 4U>(rinstr.low);",
                "const u16 op = Bm16::IsolateBit<15U>(rinstr.high);",
                "if ((op1 == 0b10U) && (op == 0b1U)) {",
                "  // ## Branches and miscellaneous control",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p142",
                "  const u16 _op1 = Bm16::Slice1R<14U, 12U>(rinstr.high);",
                "  const u16 _op = Bm16::Slice1R<10U, 4U>(rinstr.low);",
                "  if ((_op1 == 0b000U || _op1 == 0b010U) && (Bm16::Slice1R<5U, 3U>(_op)!=0b111U)) {",
                "    return BT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((_op1 == 0b000U || _op1 == 0b010U) && (Bm16::Slice1R<6U, 1U>(_op)==0b011100U)) {",
                "    return MsrT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((_op1 == 0b000U || _op1 == 0b010U) && (Bm16::Slice1R<6U, 1U>(_op)==0b011111U)) {",
                "    return MrsT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b001U || _op1 == 0b011U) { // attention the x in the docs does not mean hex",
                "    return BT4Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b101U || _op1 == 0b111U) {",
                "    return BlT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((_op1 == 0b000U || _op1 == 0b010U) && (_op == 0b0111011U)) {",
                "    // ### Miscellaneous control instructions",
                "    // see Armv7-M Architecture Reference Manual Issue E.e p143",
                "    const u16 _opc = Bm16::Slice1R<7U, 4U>(rinstr.high);",
                "    // const u16 _option = Bm16::Slice1R<3U, 0U>(rinstr.high);",
                "    if (_opc == 0b0101U) { ",
                "      return DmbT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "    }",
                "  }",
                "} else if ((op1 == 0b10U) && (Bm16::IsolateBit<5U>(op2) == 0b0U) && (op == 0x0U)) {",
                "  // ## Data processing (modified immediate)",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p138",
                "  const u16 _op = Bm16::Slice1R<8U, 4U>(rinstr.low);",
                "  const u16 _Rd = Bm16::Slice1R<11U, 8U>(rinstr.high);",
                "  const u16 _Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                "  if ((Bm16::Slice1R<4U, 1U>(_op) == 0b0000U)  && _Rd == 0b1111U) {",
                "    return TstImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4U, 1U>(_op) == 0b0000U)  && _Rd != 0b1111U) {",
                "    return AndImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4U, 1U>(_op) == 0b0010U)  && _Rn != 0b1111U) {",
                "    return OrrImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4U, 1U>(_op) == 0b0010U)  && _Rn == 0b1111U) {",
                "    return MovImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4U, 1U>(_op) == 0b0011U)  && _Rn == 0b1111U) {",
                "    return MvnImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4U, 1U>(_op) == 0b0100U)  && _Rd != 0b1111U) {",
                "    return EorImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4U, 1U>(_op) == 0b0100U)  && _Rd == 0b1111U) {",
                "    return TeqImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (Bm16::Slice1R<4U, 1U>(_op) == 0b0001U) {",
                "    return BicImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4U, 1U>(_op) == 0b1000U) && _Rd != 0b1111U) {",
                "    return AddImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);  ",
                "  } else if ((Bm16::Slice1R<4U, 1U>(_op) == 0b1000U) && _Rd == 0b1111U) {",
                "    return CmnImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (Bm16::Slice1R<4U, 1U>(_op) == 0b1010U) {",
                "    return AdcImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4U, 1U>(_op) == 0b1101U) && _Rd != 0b1111U) {",
                "    return SubImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4U, 1U>(_op) == 0b1101U) && _Rd == 0b1111U) {",
                "    return CmpImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (Bm16::Slice1R<4U, 1U>(_op) == 0b1011U) {",
                "    return SbcImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (Bm16::Slice1R<4U, 1U>(_op) == 0b1110U) {",
                "    return RsbImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                " } else if ((op1 == 0b10U) && (Bm16::IsolateBit<5U>(op2) == 0b1U) && (op == 0x0U)) {",
                "  // ## Data processing (plain binary immediate)",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p141",
                "  const u16 _op = Bm16::Slice1R<8U, 4U>(rinstr.low);",
                "  const u16 _Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                "  if (_op == 0b00100U) {",
                "    return MovImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op == 0b00000U && _Rn != 0b1111U){",
                "    return AddImmediateT4Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op == 0b01010U && _Rn != 0b1111U){",
                "    return SubImmediateT4Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op == 0b10110U && _Rn != 0b1111U){",
                "    return BfiT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op == 0b11100U) {",
                "    return UbfxT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "}"
            ]
        },
        "32bit_op11111": {
            "flags": [
                "32bit"
            ],
            "splitters": [
                "// # 32-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p137",
                "// op1 is set by jump table",
                "const u16 op2 = Bm16::Slice1R<10U, 4U>(rinstr.low);",
                "if ((Bm16::Slice1R<6U, 4U>(op2) == 0b000U) && (Bm16::Slice1R<0U, 0U>(op2) == 0b0U)) {",
                "   // ## Store single data item",
                "   // see Armv7-M Architecture Reference Manual Issue E.e p149",
                "   const u16 _op1 = Bm16::Slice1R<7U, 5U>(rinstr.low);",
                "   const u16 _op2 = Bm16::Slice1R<11U, 6U>(rinstr.high);",
                "   if (_op1 == 0b100U) {",
                "     return StrbImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b101U) {",
                "     return StrhImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b001U && Bm16::IsolateBit<5U>(_op2) == 0b1U) {",
                "     return StrhImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b000U && Bm16::IsolateBit<5U>(_op2) == 0b1U) {",
                "     return StrbImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b010U && Bm16::IsolateBit<5U>(_op2) == 0b1U) {",
                "     return StrImmediateT4Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b010U && Bm16::IsolateBit<5U>(_op2) == 0b0U) {",
                "     return StrRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b001U && Bm16::IsolateBit<5U>(_op2) == 0b0U) {",
                "     return StrhRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b000U && Bm16::IsolateBit<5U>(_op2) == 0b0U) {",
                "     return StrbRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b110U) {",
                "     return StrImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   }",
                "} else if ((Bm16::Slice1R<6U, 5U>(op2) == 0b00U) && (Bm16::Slice1R<2U, 0U>(op2) == 0b001U)) {",
                "   // ## Load byte, memory hints",
                "   // see Armv7-M Architecture Reference Manual Issue E.e p148",
                "   const u16 _op1 = Bm16::Slice1R<8U, 7U>(rinstr.low);",
                "   const u16 _op2 = Bm16::Slice1R<11U, 6U>(rinstr.high);",
                "   const u16 _Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                "   const u16 _Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                "   if (_op1 == 0b01U && _Rn != 0b1111 && _Rt != 0b1111U) {",
                "     return LdrbImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b00U && (Bm16::IsolateBit<5U>(_op2) == 0b1U) && (Bm16::Slice1R<2U, 2U>(_op2) == 0b1U) && _Rn != 0b1111 && _Rt != 0b1111U) {",
                "     return LdrbImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b00U && Bm16::Slice1R<5U, 2U>(_op2) == 0b1100U && _Rn != 0b1111 && _Rt != 0b1111U) {",
                "     return LdrbImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b11U && _Rn != 0b1111 && _Rt != 0b1111U) {",
                "     return LdrsbImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   }",
                "} else if ((Bm16::Slice1R<6U, 5U>(op2) == 0b00U) && (Bm16::Slice1R<2U, 0U>(op2) == 0b011U)) {",
                "   // ## Load halfword, memory hints",
                "   // see Armv7-M Architecture Reference Manual Issue E.e p147",
                "   const u16 _op1 = Bm16::Slice1R<8U, 7U>(rinstr.low);",
                "   const u16 _op2 = Bm16::Slice1R<11U, 6U>(rinstr.high);",
                "   const u16 _Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                "   const u16 _Rt = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                "   if (_op1 == 0b01U && _Rn != 0b1111U  && _Rt != 0b1111U) {",
                "     return LdrhImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b00U && (_op2 == 0b000000U) && _Rn != 0b1111U  && _Rt != 0b1111U) {",
                "     return LdrhRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b11U && _Rn != 0b1111U  && _Rt != 0b1111U) {",
                "     return LdrshImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b00U &&  Bm16::Slice1R<2U, 2U>(_op2) == 0b1U && Bm16::IsolateBit<5U>(_op2) == 0b1U &&_Rn != 0b1111U  && _Rt != 0b1111U) {",
                "     return LdrhImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b00U &&  Bm16::Slice1R<5U, 2U>(_op2) == 0b1100U && _Rn != 0b1111U  && _Rt != 0b1111U) {",
                "     return LdrhImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b10U &&  Bm16::Slice1R<2U, 2U>(_op2) == 0b1U && Bm16::IsolateBit<5U>(_op2) == 0b1U &&_Rn != 0b1111U  && _Rt != 0b1111U) {",
                "     return LdrshImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b10U &&  Bm16::Slice1R<5U, 2U>(_op2) == 0b1100U && _Rn != 0b1111U  && _Rt != 0b1111U) {",
                "     return LdrshImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   }",
                "} else if ((Bm16::Slice1R<6U, 5U>(op2) == 0b00U) && (Bm16::Slice1R<2U, 0U>(op2) == 0b101U)) {",
                "  // ## Load word",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p146",
                "  const u16 _op1 = Bm16::Slice1R<8U, 7U>(rinstr.low);",
                "  const u16 _op2 = Bm16::Slice1R<11U, 6U>(rinstr.high);",
                "  const u16 _Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                "  if ((Bm16::Slice1R<1U, 1U>(_op1) == 0b0U) && _Rn == 0b1111U) {",
                "    return LdrLiteralT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b01U && _Rn != 0b1111U){",
                "    return LdrImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b00U && Bm16::IsolateBit<5U>(_op2) == 0b1U && (Bm16::Slice1R<2U, 2U>(_op2) == 0b1U)&& _Rn != 0b1111U) {",
                "    return LdrImmediateT4Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b00U && Bm16::Slice1R<5U, 2U>(_op2) == 0b1100U && _Rn != 0b1111U) {",
                "    return LdrImmediateT4Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b00U && _op2 == 0b000000U && _Rn !=0b1111U) {",
                "    return LdrRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "} else if (Bm16::Slice1R<6U, 4U>(op2) == 0b010U) {",
                "  // ## Data processing (register)",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p152",
                "  const u16 _op1 = Bm16::Slice1R<7U, 4U>(rinstr.low);",
                "  const u16 _op2 = Bm16::Slice1R<7U, 4U>(rinstr.high);",
                "  const u16 _Rn = Bm16::Slice1R<3U, 0U>(rinstr.low);",
                "  if ((Bm16::Slice1R<3U, 1U>(_op1) == 0b000U) && _op2 == 0b0000U) {",
                "    return LslRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<3U, 1U>(_op1) == 0b001U) && _op2 == 0b0000U) {",
                "    return LsrRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<3U, 1U>(_op1) == 0b010U) && _op2 == 0b0000U) {",
                "    return AsrRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b0001U && (Bm16::Slice1R<3U, 3U>(_op2) == 0b1U) && _Rn == 0b1111U) {",
                "    return UxthT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b0100U && (Bm16::Slice1R<3U, 3U>(_op2) == 0b1U) && _Rn == 0b1111U) {",
                "    return SxtbT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b0000U && (Bm16::Slice1R<3U, 3U>(_op2) == 0b1U) && _Rn == 0b1111U) {",
                "    return SxthT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b0101U && (Bm16::Slice1R<3U, 3U>(_op2) == 0b1U) && _Rn == 0b1111U) {",
                "    return UxtbT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<3U, 2U>(_op1) == 0b10U) && (Bm16::Slice1R<3U, 2U>(_op2) == 0b10U)) {",
                "    // ## Miscellaneous operations",
                "    // see Armv7-M Architecture Reference Manual Issue E.e p155",
                "    const u32 __op1 = Bm16::Slice1R<5U, 4U>(rinstr.low);",
                "    const u32 __op2 = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                "    if ((__op1 == 0b11U) && (__op2 == 0b00U)) {",
                "      return ClzT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "    }",
                "  }",
                "} else if (Bm16::Slice1R<6U, 3U>(op2) == 0b0110U) {",
                "  // ## Multiply, multiply accumulate, and absolute difference",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p156",
                "  const u16 _op1 = Bm16::Slice1R<6U, 4U>(rinstr.low);",
                "  const u16 _op2 = Bm16::Slice1R<5U, 4U>(rinstr.high);",
                "  const u16 _Ra = Bm16::Slice1R<15U, 12U>(rinstr.high);",
                "  if (_op1 == 0b000U && _op2 == 0b00U && _Ra == 0b1111U) {",
                "    return MulT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b000U && _op2 == 0b00U && _Ra!=0b1111U) {",
                "    return MlaT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b000U && _op2 == 0b01U) {",
                "    return MlsT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "} else if (Bm16::Slice1R<6U, 3U>(op2) == 0b0111U) {",
                "  // ## Long multiply, long multiply accumulate, and divide",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p156",
                "  const u16 _op1 = Bm16::Slice1R<6U, 4U>(rinstr.low);",
                "  const u16 _op2 = Bm16::Slice1R<7U, 4U>(rinstr.high);",
                "  if (_op1 == 0b010U && _op2 == 0b0000U) {",
                "    return UmullT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b000U && _op2 == 0b0000U) {",
                "    return SmullT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b011U && _op2 == 0b1111U) {",
                "    return UdivT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b001U && _op2 == 0b1111U) {",
                "    return SdivT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b110U && _op2 == 0b0000U) {",
                "    return UmlalT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "}"
            ]
        }
    },
    "opcodes": {
        "00000": {
            "decoder": "16bit_op00000"
        },
        "00001": {
            "decoder": "lsr_immediate_t1"
        },
        "00010": {
            "decoder": "asr_immediate_t1"
        },
        "00011": {
            "decoder": "16bit_op00011"
        },
        "00100": {
            "decoder": "mov_immediate_t1"
        },
        "00101": {
            "decoder": "cmp_immediate_t1"
        },
        "00110": {
            "decoder": "add_immediate_t2"
        },
        "00111": {
            "decoder": "sub_immediate_t2"
        },
        "01000": {
            "decoder": "16bit_op01000"
        },
        "01001": {
            "decoder": "ldr_literal_t1"
        },
        "01010": {
            "decoder": "16bit_op01010"
        },
        "01011": {
            "decoder": "16bit_op01011"
        },
        "10000": {
            "decoder": "strh_immediate_t1"
        },
        "01100": {
            "decoder": "str_immediate_t1"
        },
        "01101": {
            "decoder": "16bit_op01101"
        },
        "01110": {
            "decoder": "strb_immediate_t1"
        },
        "01111": {
            "decoder": "ldrb_immediate_t1"
        },
        "10001": {
            "decoder": "ldrh_immediate_t1"
        },
        "10010": {
            "decoder": "str_immediate_t2"
        },
        "10100": {
            "decoder": "add_pc_plus_immediate_t1"
        },
        "10101": {
            "decoder": "add_sp_plus_immediate_t1"
        },
        "10110": {
            "decoder": "16bit_op10110"
        },
        "10111": {
            "decoder": "16bit_op10111"
        },
        "10011": {
            "decoder": "ldr_immediate_t2"
        },
        "11010": {
            "decoder": "b_t1"
        },
        "11000": {
            "decoder": "stm_t1"
        },
        "11001": {
            "decoder": "ldm_t1"
        },
        "11011": {
            "decoder": "16bit_op11011"
        },
        "11100": {
            "decoder": "b_t2"
        },
        "11101": {
            "decoder": "32bit_op11101"
        },
        "11110": {
            "decoder": "32bit_op11110"
        },
        "11111": {
            "decoder": "32bit_op11111"
        }
    }
}