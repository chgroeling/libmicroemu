{
    "instructions": {
        "nop": {},
        "dmb": {},
        "add_pc_plus_immediate": {
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "lsl_immediate": {
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "lsl_register": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            }
        },
        "clz": {
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            }
        },
        "sxth": {
            "m": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "rotation": {
                "type": "u8"
            }
        },
        "tbb_h": {
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "cmp_register": {
            "n": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "cmp_immediate": {
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "cmn_immediate": {
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "mov_immediate": {
            "d": {
                "type": "u8"
            },
            "imm32_carry": {
                "type": "ThumbImmediateResult"
            }
        },
        "mvn_immediate": {
            "d": {
                "type": "u8"
            },
            "imm32_carry": {
                "type": "ThumbImmediateResult"
            }
        },
        "mov_register": {
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            }
        },
        "rrx": {
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            }
        },
        "ldrb_immediate": {
            "t": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "ldrsb_immediate": {
            "t": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "ldrh_immediate": {
            "t": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "ldrsh_immediate": {
            "t": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "ldr_immediate": {
            "t": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "ldrex": {
            "t": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "ldrd_immediate": {
            "t": {
                "type": "u8"
            },
            "t2": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "ldr_literal": {
            "t": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "it": {
            "firstcond": {
                "type": "u8"
            },
            "mask": {
                "type": "u8"
            }
        },
        "cb_n_z": {
            "n": {
                "type": "u8"
            },
            "imm32": {
                "type": "i32"
            }
        },
        "bl": {
            "imm32": {
                "type": "i32"
            }
        },
        "bx": {
            "m": {
                "type": "u8"
            }
        },
        "blx": {
            "m": {
                "type": "u8"
            }
        },
        "b_cond": {
            "cond": {
                "type": "u8"
            },
            "imm32": {
                "type": "i32"
            }
        },
        "b": {
            "imm32": {
                "type": "i32"
            }
        },
        "bfi": {
            "d": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "lsbit": {
                "type": "u8"
            },
            "msbit": {
                "type": "u8"
            }
        },
        "udiv": {
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "sdiv": {
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "mul": {
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "umlal": {
            "dHi": {
                "type": "u8"
            },
            "dLo": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "umull": {
            "dHi": {
                "type": "u8"
            },
            "dLo": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "smull": {
            "dHi": {
                "type": "u8"
            },
            "dLo": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "mls": {
            "a": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "mla": {
            "a": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            }
        },
        "sub_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "sbc_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "rsb_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "sub_sp_minus_immediate": {
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "sub_register": {
            "shift_res": {
                "type": "ImmShiftResults"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            }
        },
        "rsb_register": {
            "shift_res": {
                "type": "ImmShiftResults"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            }
        },
        "add_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "adc_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "add_sp_plus_immediate": {
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "tst_immediate": {
            "n": {
                "type": "u8"
            },
            "imm32_carry": {
                "type": "ThumbImmediateResult"
            }
        },
        "teq_immediate": {
            "n": {
                "type": "u8"
            },
            "imm32_carry": {
                "type": "ThumbImmediateResult"
            }
        },
        "tst_register": {
            "n": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "teq_register": {
            "n": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "and_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32_carry": {
                "type": "ThumbImmediateResult"
            }
        },
        "add_register": {
            "shift_res": {
                "type": "ImmShiftResults"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            }
        },
        "adc_register": {
            "shift_res": {
                "type": "ImmShiftResults"
            },
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            }
        },
        "stmdb": {
            "n": {
                "type": "u8"
            },
            "registers": {
                "type": "u32"
            }
        },
        "push": {
            "registers": {
                "type": "u32"
            }
        },
        "stm": {
            "registers": {
                "type": "u32"
            },
            "n": {
                "type": "u8"
            }
        },
        "pop": {
            "registers": {
                "type": "u32"
            }
        },
        "ldm": {
            "registers": {
                "type": "u32"
            },
            "n": {
                "type": "u8"
            }
        },
        "uxtb": {
            "m": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "rotation": {
                "type": "u8"
            }
        },
        "sxtb": {
            "m": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "rotation": {
                "type": "u8"
            }
        },
        "uxth": {
            "m": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "rotation": {
                "type": "u8"
            }
        },
        "ubfx": {
            "d": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "lsbit": {
                "type": "u8"
            },
            "widthminus1": {
                "type": "u8"
            }
        },
        "orr_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32_carry": {
                "type": "ThumbImmediateResult"
            }
        },
        "orr_register": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "eor_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32_carry": {
                "type": "ThumbImmediateResult"
            }
        },
        "eor_register": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "sbc_register": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "and_register": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "bic_register": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "bic_immediate": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32_carry": {
                "type": "ThumbImmediateResult"
            }
        },
        "mvn_register": {
            "m": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "lsr_immediate": {
            "m": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "asr_immediate": {
            "m": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "lsr_register": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            }
        },
        "asr_register": {
            "n": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            }
        },
        "strd_immediate": {
            "n": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "t2": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "str_register": {
            "n": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "strb_register": {
            "n": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "strh_register": {
            "n": {
                "type": "u8"
            },
            "m": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "ldrb_register": {
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "ldrh_register": {
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "ldr_register": {
            "m": {
                "type": "u8"
            },
            "n": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "shift_res": {
                "type": "ImmShiftResults"
            }
        },
        "strb_immediate": {
            "n": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "strh_immediate": {
            "n": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "str_immediate": {
            "n": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "strex": {
            "n": {
                "type": "u8"
            },
            "t": {
                "type": "u8"
            },
            "d": {
                "type": "u8"
            },
            "imm32": {
                "type": "u32"
            }
        },
        "svc": {
            "imm32": {
                "type": "u32"
            }
        },
        "bkpt": {
            "imm32": {
                "type": "u32"
            }
        },
        "msr": {
            "n": {
                "type": "u8"
            },
            "mask": {
                "type": "u8"
            },
            "SYSm": {
                "type": "u8"
            }
        },
        "mrs": {
            "d": {
                "type": "u8"
            },
            "mask": {
                "type": "u8"
            },
            "SYSm": {
                "type": "u8"
            }
        }
    },
    "decoders": {
        "nop_t1": {
            "instruction": "nop",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "static_cast<void>(rinstr);"
            ],
            "def": {},
            "post_block": [
                "assert(rinstr.low == 0b1011111100000000u);"
            ]
        },
        "dmb_t1": {
            "instruction": "dmb",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert(rinstr.low == 0b1111001110111111u);",
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.high)) == 0b100011110101u);",
                "static_cast<void>(rinstr);"
            ],
            "def": {},
            "post_block": []
        },
        "add_pc_plus_immediate_t1": {
            "instruction": "add_pc_plus_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b10100u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<10u, 8u>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8<<2u);"
                    ]
                }
            },
            "post_block": []
        },
        "lsl_immediate_t1": {
            "instruction": "lsl_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b00000u);",
                "assert((Bm16::Slice1R<10u, 6u>(rinstr.low)) != 0x0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |= TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u16 imm5 = Bm16::Slice1R<10u, 6u>(rinstr.low);",
                        "const auto shift_res = Alu32::DecodeImmShift(0b00, imm5);"
                    ]
                }
            },
            "post_block": [
                "assert(shift_res.type == SRType::SRType_LSL);"
            ]
        },
        "lsl_immediate_t2": {
            "instruction": "lsl_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11101010010u);",
                "assert((Bm16::Slice1R<3u, 0u>(rinstr.low)) == 0b1111u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);",
                "assert((Bm16::Slice1R<5u, 4u>(rinstr.high)) == 0b00u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u16 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u16 imm2 = Bm16::Slice1R<7u, 6u>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(0b00u, (imm3<<2u) | imm2);"
                    ]
                }
            },
            "post_block": [
                "assert(shift_res.type == SRType::SRType_LSL);",
                "assert(((imm3 << 2u) | imm2) != 0b0u);",
                "if (d == 13u || d == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "lsl_register_t1": {
            "instruction": "lsl_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 6u>(rinstr.low)) == 0b0100000010u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": []
        },
        "lsl_register_t2": {
            "instruction": "lsl_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11111010000u);",
                "assert((Bm16::Slice1R<15u, 12u>(rinstr.high)) == 0b1111u);",
                "assert((Bm16::Slice1R<7u, 4u>(rinstr.high)) == 0b0000u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15 || n == 13u || n == 15 || m == 13u || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "clz_t1": {
            "instruction": "clz",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110101011u);",
                "assert((Bm16::Slice1R<15u, 12u>(rinstr.high)) == 0b1111u);",
                "assert((Bm16::Slice1R<7u, 4u>(rinstr.high)) == 0b1000u);"
            ],
            "def": {
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm_1 = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u16 Rm_2 = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "if (Rm_1 != Rm_2) {",
                        "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                        "}",
                        "const u8 m = static_cast<u8>(Rm_1);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15 || m == 13u || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "asr_immediate_t1": {
            "instruction": "asr_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b00010u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<10u, 6u>(rinstr.low);",
                        "const auto shift_res =Alu32::DecodeImmShift(0b10u, imm5);"
                    ]
                }
            },
            "post_block": []
        },
        "cmp_register_t1": {
            "instruction": "cmp_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<10u, 6u>(rinstr.low)) == 0b01010u);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, 0u};"
                    ]
                }
            },
            "post_block": []
        },
        "cmp_register_t2": {
            "instruction": "cmp_register",
            "encoding": "t2",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<10u, 8u>(rinstr.low)) == 0b101u);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 N = Bm16::IsolateBit<7u>(rinstr.low);",
                        "const u16 Rn = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(N<<3u | Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<6u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, 0u};"
                    ]
                }
            },
            "post_block": [
                "if (n < 8u && m < 8u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (n == 15u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "cmp_register_t3": {
            "instruction": "cmp_register",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111010111011u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);",
                "assert((Bm16::Slice1R<11u, 8u>(rinstr.high)) == 0b1111u);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u16 type = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                        "const u16 imm2 = Bm16::Slice1R<7u, 6u>(rinstr.high);",
                        "const u16 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2) | imm2);"
                    ]
                }
            },
            "post_block": [
                "if (n == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "cmp_immediate_t1": {
            "instruction": "cmp_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b00101u);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<10u, 8u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            }
        },
        "cmp_immediate_t2": {
            "instruction": "cmp_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 4u>(rinstr.low)) == 0b011011u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);",
                "assert((Bm16::Slice1R<11u, 8u>(rinstr.high)) == 0b1111u);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "TRY_ASSIGN(imm32, Instr,Thumb::ThumbExpandImm((i<< 11u)| (imm3<<8u) | imm8));"
                    ]
                }
            },
            "post_block": [
                "if (n == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "cmn_immediate_t1": {
            "instruction": "cmn_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 4u>(rinstr.low)) == 0b010001u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);",
                "assert((Bm16::Slice1R<11u, 8u>(rinstr.high)) == 0b1111u);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "TRY_ASSIGN(imm32, Instr, Thumb::ThumbExpandImm((i << 11u)| (imm3 << 8u) | imm8));"
                    ]
                }
            },
            "post_block": [
                "if (n == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mov_immediate_t1": {
            "instruction": "mov_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b00100u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<10u, 8u>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "const u16 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.low);",
                        "const auto imm32_carry = ThumbImmediateResult{imm8, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk};"
                    ]
                }
            },
            "post_block": []
        },
        "mov_immediate_t2": {
            "instruction": "mov_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 5u>(rinstr.low)) == 0b00010u);",
                "assert((Bm16::Slice1R<3u, 0u>(rinstr.low)) == 0b1111u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "TRY_ASSIGN(imm32_carry, Instr,Thumb::ThumbExpandImm_C(imm12, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk));"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mov_immediate_t3": {
            "instruction": "mov_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 4u>(rinstr.low)) == 0b100100u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm4 = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const auto imm32_carry = ThumbImmediateResult{(imm4<<12u) | (i<< 11u) | (imm3<<8u) | imm8, false};"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mvn_immediate_t1": {
            "instruction": "mvn_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 5u>(rinstr.low)) == 0b00011u);",
                "assert((Bm16::Slice1R<3u, 0u>(rinstr.low)) == 0b1111u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "TRY_ASSIGN(imm32_carry, Instr,Thumb::ThumbExpandImm_C(imm12, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk));"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "tbb_h_t1": {
            "instruction": "tbb_h",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111010001101u);",
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.high)) == 0b11110000000u);"
            ],
            "def": {
                "tbh": {
                    "flag_decoder": [
                        "const u32 H = Bm16::IsolateBit<4u>(rinstr.high);",
                        "flags |= H << static_cast<InstrFlagsSet>(InstrFlagsShift::kTbhShift);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (n == 13u || m == 13u  || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if ( TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "rsb_immediate_t1": {
            "instruction": "rsb_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 6u>(rinstr.low)) == 0b0100001001u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm32 = 0x0u;"
                    ]
                }
            },
            "post_block": []
        },
        "rsb_immediate_t2": {
            "instruction": "rsb_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 5u>(rinstr.low)) == 0b01110u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "TRY_ASSIGN(imm32, Instr,Thumb::ThumbExpandImm(imm12));"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u || n == 13u ||  n == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mov_register_t1": {
            "instruction": "mov_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<11u, 8u>(rinstr.low)) == 0x6u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm32::Slice2R<7u, 7u, 2u, 0u>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<6u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if (d == 15u &&  TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mov_register_t2": {
            "instruction": "mov_register",
            "encoding": "t2",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 6u>(rinstr.low)) == 0b0000000000u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if ( TItOps::InITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mov_register_t3": {
            "instruction": "mov_register",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11101010010u);",
                "assert((Bm16::Slice1R<3u, 0u>(rinstr.low)) == 0b1111u);",
                "assert((Bm16::Slice1R<15u, 12u>(rinstr.high)) == 0b0000u);",
                "assert((Bm16::Slice1R<7u, 4u>(rinstr.high)) == 0b0000u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if ((flags& static_cast<InstrFlagsSet>(InstrFlags::kSetFlags) != 0u) && (d==13u || d==15u || m==13u || m==15u)) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if ((flags& static_cast<InstrFlagsSet>(InstrFlags::kSetFlags) == 0u) && (d==15u || m==15u || (d==13u && m==13u))) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "rrx_t1": {
            "instruction": "rrx",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11101010010u);",
                "assert((Bm16::Slice1R<3u, 0u>(rinstr.low)) == 0b1111u);",
                "assert((Bm16::Slice1R<15u, 12u>(rinstr.high)) == 0b0000u);",
                "assert((Bm16::Slice1R<7u, 4u>(rinstr.high)) == 0b0011u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if ((d == 13u) || (d == 15u) || (m == 13u) || (m == 15u)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldr_literal_t1": {
            "instruction": "ldr_literal",
            "encoding": "t1",
            "flags": [],
            "pre_block": [],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<10u, 8u>(rinstr.low);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u16 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8) << 2u;"
                    ]
                }
            }
        },
        "ldr_literal_t2": {
            "instruction": "ldr_literal",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 8u>(rinstr.low)) == 0b11111000u);",
                "assert((Bm16::Slice1R<6u, 0u>(rinstr.low)) == 0b1011111u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<7u>(rinstr.low);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "if (t == 15u &&  TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrb_immediate_t1": {
            "instruction": "ldrb_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b01111u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<10u, 6u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm5);"
                    ]
                }
            },
            "post_block": []
        },
        "ldrb_immediate_t2": {
            "instruction": "ldrb_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110001001u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "assert (Rt != 0b1111u);",
                "assert (Rn != 0b1111u);",
                "if (t == 13u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrb_immediate_t3": {
            "instruction": "ldrb_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110000001u);",
                "assert((Bm16::IsolateBit<11u>(rinstr.high)) == 0b1u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<9u>(rinstr.high);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = Bm16::IsolateBit<10u>(rinstr.high);",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<8u>(rinstr.high);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": [
                "assert ((Rt != 0b1111u) || (P!=1u) || (U!=0u) || (W!=0u));",
                "assert (Rn != 0b1111u);",
                "assert ((P != 0b1u) || (U != 0b1u) || (W != 0b0u));",
                "assert ((Rn != 0b1101u) || (P != 0x0u) || (U != 0x1u) || (W != 0x1u) || (imm8 != 0b00000100u) );",
                "if ((P == 0x0u) && (W == 0x0u) ) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 13u || (flags & static_cast<InstrFlagsSet>(InstrFlags::kWBack) && n == t)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (t == 15u && ((P == 0u)||(U == 1u)||(W == 1u))) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrsb_immediate_t1": {
            "instruction": "ldrsb_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110011001u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "assert (Rt != 0b1111u);",
                "assert (Rn != 0b1111u);",
                "if (t == 13u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrsb_immediate_t2": {
            "instruction": "ldrsb_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert(false); // not tested",
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110010001u);",
                "assert((Bm16::IsolateBit<11u>(rinstr.high)) == 0b1u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<9u>(rinstr.high);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = Bm16::IsolateBit<10u>(rinstr.high);",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<8u>(rinstr.high);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": [
                "assert ((Rt != 0b1111u) || (P!=1u) || (U!=0u) || (W!=0u));",
                "assert (Rn != 0b1111u);",
                "assert ((P != 0b1u) || (U != 0b1u) || (W != 0b0u));",
                "assert ((Rn != 0b1101u) || (P != 0x0u) || (U != 0x1u) || (W != 0x1u) || (imm8 != 0b00000100u) );",
                "if ((P == 0x0u) && (W == 0x0u) ) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 13u || (t == 15u && (W == 1u)) || (flags & static_cast<InstrFlagsSet>(InstrFlags::kWBack) && n == t)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrsh_immediate_t1": {
            "instruction": "ldrsh_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110011011u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "assert(Rn!=0b1111u);",
                "assert(Rt!=0b1111u);",
                "if (t == 13u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrsh_immediate_t2": {
            "instruction": "ldrsh_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110010011u);",
                "assert((Bm16::IsolateBit<11u>(rinstr.high)) == 0b1u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = static_cast<u32>(Bm16::IsolateBit<9u>(rinstr.high));",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = static_cast<u32>(Bm16::IsolateBit<10u>(rinstr.high));",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = static_cast<u32>(Bm16::IsolateBit<8u>(rinstr.high));",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = static_cast<u32>(Bm16::Slice1R<7u, 0u>(rinstr.high));",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": [
                "assert (Rn != 0b1111u);",
                "assert (Rt != 0b1111u || P != 1u || U != 0u || W != 0u);",
                "assert (P != 0b1u || U != 0b1u || W != 0b0u);",
                "if (P == 0b0u && W == 0b0u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 13u || (t == 15u && W == 1u) || (flags & static_cast<InstrFlagsSet>(InstrFlags::kWBack) && n == t)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrh_immediate_t1": {
            "instruction": "ldrh_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b10001u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<10u, 6u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm5<<1u);"
                    ]
                }
            },
            "post_block": []
        },
        "ldrh_immediate_t2": {
            "instruction": "ldrh_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110001011u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "assert (Rt != 0b1111u);",
                "assert (Rn != 0b1111u);",
                "if (t == 13u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrh_immediate_t3": {
            "instruction": "ldrh_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110000011u);",
                "assert((Bm16::IsolateBit<11u>(rinstr.high)) == 0b1u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = static_cast<u32>(Bm16::IsolateBit<9u>(rinstr.high));",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = static_cast<u32>(Bm16::IsolateBit<10u>(rinstr.high));",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = static_cast<u32>(Bm16::IsolateBit<8u>(rinstr.high));",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = static_cast<u32>(Bm16::Slice1R<7u, 0u>(rinstr.high));",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": [
                "assert (Rn != 0b1111u);",
                "assert (Rt != 0b1111u || P != 1u || U != 0u || W != 0u);",
                "assert (P != 0b1u || U != 0b1u || W != 0b0u);",
                "if (P == 0b0u && W == 0b0u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 13u || (t == 15u && W == 1u) || (flags & static_cast<InstrFlagsSet>(InstrFlags::kWBack) && n == t)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "pop_t1": {
            "instruction": "pop",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 9u>(rinstr.low)) == 0b1011110u);"
            ],
            "def": {
                "UnalignedAllow": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kUnalignedAllow);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u32 P = Bm16::IsolateBit<8u>(rinstr.low);",
                        "const u32 register_list = Bm16::Slice1R<7u, 0u>(rinstr.low);",
                        "const u32 registers = (P<<15u) | register_list;"
                    ]
                }
            },
            "post_block": [
                "if (Bm32::BitCount(registers) < 1u) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if ((Bm32::Slice1R<15u, 15u>(registers) == 0x1u) && ( TItOps::InITBlock(pstates)) && (! TItOps::LastInITBlock(pstates))) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "pop_t2": {
            "instruction": "pop",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 0u>(rinstr.low)) == 0b1110100010111101u);",
                "assert((Bm16::IsolateBit<13u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "UnalignedAllow": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kUnalignedAllow);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u32 P = Bm16::IsolateBit<15u>(rinstr.high);",
                        "const u32 M = Bm16::IsolateBit<14u>(rinstr.high);",
                        "const u32 register_list = Bm16::Slice1R<12u, 0u>(rinstr.high);",
                        "const u32 registers = (P<<15u) | (M<<14u) | register_list;"
                    ]
                }
            },
            "post_block": [
                "if ((Bm32::BitCount(registers) < 2u) || ((P == 1u) && M == 1u)) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if ((Bm32::Slice1R<15u, 15u>(registers) == 0x1u) && ( TItOps::InITBlock(pstates)) && (! TItOps::LastInITBlock(pstates))) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "pop_t3": {
            "instruction": "pop",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 0u>(rinstr.low)) == 0b1111100001011101u);",
                "assert((Bm16::Slice1R<11u, 0u>(rinstr.high)) == 0b101100000100u);"
            ],
            "def": {
                "UnalignedAllow": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kUnalignedAllow);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);",
                        "const u32 registers = 1u << Rt;"
                    ]
                }
            },
            "post_block": [
                "if (t == 13u || (t == 15u &&  TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates))) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldr_immediate_t1": {
            "instruction": "ldr_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b01101u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<10u, 6u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm5<<2u);"
                    ]
                }
            },
            "post_block": []
        },
        "ldr_immediate_t2": {
            "instruction": "ldr_immediate",
            "encoding": "t2",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b10011u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<10u, 8u>(rinstr.low);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u8 n = 13u;"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8 << 2u);"
                    ]
                }
            },
            "post_block": []
        },
        "ldr_immediate_t3": {
            "instruction": "ldr_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110001101u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "if (t == 15u &&  TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldr_immediate_t4": {
            "instruction": "ldr_immediate",
            "encoding": "t4",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110000101u);",
                "assert((Bm16::IsolateBit<11u>(rinstr.high)) == 0b1u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<9u>(rinstr.high);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = Bm16::IsolateBit<10u>(rinstr.high);",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<8u>(rinstr.high);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": [
                "assert (Rn != 0b1111u);",
                "assert ((P != 0b1u) || (U != 0b1u) || (W != 0b0u));",
                "if ((Rn == 0b1101u)  && (P == 0x0u) && (U == 0x1u) && (W == 0x1u) && (imm8 == 0b00000100u) ) {",
                "  // SEE POP",
                "  return PopT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}",
                "if ((P == 0x0u) && (W == 0x0u) ) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if ((flags & static_cast<InstrFlagsSet>(InstrFlags::kWBack) && n == t) || t == 15u &&  TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}"
            ]
        },
        "ldrex_t1": {
            "instruction": "ldrex",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111010000101u);",
                "assert((Bm16::Slice1R<11u, 8u>(rinstr.high)) == 0b1111u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": [
                "if (t == 13u || t == 15u || n == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}"
            ]
        },
        "ldrd_immediate_t1": {
            "instruction": "ldrd_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 9u>(rinstr.low)) == 0b1110100u);",
                "assert((Bm16::IsolateBit<6u>(rinstr.low)) == 0b1u);",
                "assert((Bm16::IsolateBit<4u>(rinstr.low)) == 0b1u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<7u>(rinstr.low);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = Bm16::IsolateBit<8u>(rinstr.low);",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<5u>(rinstr.low);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "t2": {
                    "decoder": [
                        "const u32 Rt2 = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 t2 = static_cast<u8>(Rt2);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8<<2u);"
                    ]
                }
            },
            "post_block": [
                "assert((P!=0u) || (W!=0));",
                "assert(Rn!=0b1111u);",
                "if (flags & static_cast<InstrFlagsSet>(InstrFlags::kWBack) && ((n == t) || (n == t2)) ) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (t == 13u || t == 15 || (t2 == 13u) || (t2 == 15)|| (t == t2)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "it_t1": {
            "instruction": "it",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<11u, 8u>(rinstr.low)) == 0xFu);"
            ],
            "def": {
                "firstcond": {
                    "decoder": [
                        "const u32 firstcond_32 = Bm16::Slice1R<7u, 4u>(rinstr.low);",
                        "const u8 firstcond = static_cast<u8>(firstcond_32);"
                    ]
                },
                "mask": {
                    "decoder": [
                        "const u32 mask_32 = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 mask = static_cast<u8>(mask_32);"
                    ]
                }
            },
            "post_block": [
                "assert(mask != 0x0u);",
                "if (firstcond == 0xFu || (firstcond == 0b1110u && Bm8::BitCount(mask) != 1u)) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "",
                "if ( TItOps::InITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "bl_t1": {
            "instruction": "bl",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 14u>(rinstr.high)) == 0x3u);",
                "assert((Bm16::IsolateBit<12u>(rinstr.high)) == 0x1u);",
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);"
            ],
            "def": {
                "imm32": {
                    "decoder": [
                        "const u32 s = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm10 = Bm16::Slice1R<9u, 0u>(rinstr.low);",
                        "const u32 j1 = Bm16::IsolateBit<13u>(rinstr.high); // bit 13",
                        "const u32 j2 = Bm16::IsolateBit<11u>(rinstr.high); // bit 11",
                        "const u32 imm11 = Bm16::Slice1R<10u, 0u>(rinstr.high); // bit 10..0",
                        "const u32 i1 = (~(j1 ^ s)) & 0x1u;",
                        "const u32 i2 = (~(j2 ^ s)) & 0x1u;",
                        "const u32 imm32_us = (s << 24u) | (i1 << 23u) | (i2 << 22u) | (imm10 << 12u) | imm11 << 1u;",
                        "const i32 imm32 = static_cast<int32_t>(Bm32::SignExtend<u32, 24u>(imm32_us));"
                    ]
                }
            },
            "post_block": [
                "if ( TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "bx_t1": {
            "instruction": "bx",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 7u>(rinstr.low) == 0b010001110u));"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<6u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if (TItOps::InITBlock(pstates) && (!TItOps::LastInITBlock(pstates))) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "blx_t1": {
            "instruction": "blx",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 7u>(rinstr.low) == 0b010001111u));"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<6u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if (m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if ( TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "b_t1": {
            "instruction": "b_cond",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "if ( TItOps::InITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ],
            "def": {
                "cond": {
                    "decoder": [
                        "const u32 cond_32 = Bm16::Slice1R<11u, 8u>(rinstr.low);",
                        "const u8 cond = static_cast<u8>(cond_32);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.low);",
                        "const i32 imm32 = Bm32::SignExtend<u32, 8u>(imm8 << 1u);"
                    ]
                }
            },
            "post_block": [
                "assert(cond!=0b1110u);",
                "assert(cond!=0b1111u);"
            ]
        },
        "b_t2": {
            "instruction": "b",
            "encoding": "t2",
            "flags": [],
            "pre_block": [],
            "def": {
                "imm32": {
                    "decoder": [
                        "const u32 imm_11_32 = Bm16::Slice1R<10u, 0u>(rinstr.low);",
                        "const i32 imm32 = Bm32::SignExtend<u32, 11u>((imm_11_32)<<1u);"
                    ]
                }
            },
            "post_block": [
                "if ( TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "b_t3": {
            "instruction": "b_cond",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<15u, 14u>(rinstr.high)) == 0b10u);",
                "assert((Bm16::IsolateBit<12u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "cond": {
                    "decoder": [
                        "const u32 cond_32 = Bm16::Slice1R<9u, 6u>(rinstr.low);",
                        "const u8 cond = static_cast<u8>(cond_32);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm11 = Bm16::Slice1R<10u, 0u>(rinstr.high);",
                        "const u32 imm6 = Bm16::Slice1R<5u, 0u>(rinstr.low);",
                        "const u32 J1 = Bm16::IsolateBit<13u>(rinstr.high); // bit 13",
                        "const u32 J2 = Bm16::IsolateBit<11u>(rinstr.high); // bit 11",
                        "const u32 S = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm32_us = (S << 20u) | (J2 << 19u) | (J1 << 18u) | (imm6 << 12u) | (imm11 << 1u);",
                        "const i32 imm32 = static_cast<int32_t>(Bm32::SignExtend<u32, 20u>(imm32_us));"
                    ]
                }
            },
            "post_block": [
                "if ( TItOps::InITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "b_t4": {
            "instruction": "b",
            "encoding": "t4",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<15u, 14u>(rinstr.high)) == 0b10u);",
                "assert((Bm16::IsolateBit<12u>(rinstr.high)) == 0b1u);"
            ],
            "def": {
                "imm32": {
                    "decoder": [
                        "const u32 imm11 = Bm16::Slice1R<10u, 0u>(rinstr.high);",
                        "const u32 imm10 = Bm16::Slice1R<9u, 0u>(rinstr.low);",
                        "const u32 J1 = Bm16::IsolateBit<13u>(rinstr.high); // bit 13",
                        "const u32 J2 = Bm16::IsolateBit<11u>(rinstr.high); // bit 11",
                        "const u32 S = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 I1 = (~(J1 ^ S)) & 0x1u;",
                        "const u32 I2 = (~(J2 ^ S)) & 0x1u;",
                        "const u32 imm32_us = (S << 24u) | (I1 << 23u) | (I2 << 22u) | (imm10 << 12u) | imm11 << 1u;",
                        "const i32 imm32 = static_cast<int32_t>(Bm32::SignExtend<u32, 24u>(imm32_us));"
                    ]
                }
            },
            "post_block": [
                "if ( TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sub_sp_minus_immediate_t1": {
            "instruction": "sub_sp_minus_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 7u>(rinstr.low)) == 0b101100001u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = 13u;"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm7 = Bm16::Slice1R<6u, 0u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm7<<2);"
                    ]
                }
            },
            "post_block": []
        },
        "sub_sp_minus_immediate_t2": {
            "instruction": "sub_sp_minus_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 5u>(rinstr.low)) == 0b01101u);",
                "assert((Bm16::Slice1R<3u, 0u>(rinstr.low)) == 0b1101u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "TRY_ASSIGN(imm32, Instr,Thumb::ThumbExpandImm(imm12));"
                    ]
                }
            },
            "post_block": [
                "assert( (d!=0b1111u) || (S!=1u) );",
                "if (d == 15u && (S == 0x0u)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sub_sp_minus_immediate_t3": {
            "instruction": "sub_sp_minus_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 0u>(rinstr.low)) == 0b1010101101u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "if (d == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sub_immediate_t1": {
            "instruction": "sub_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 9u>(rinstr.low)) == 0b0001111u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u8 n = static_cast<u8>(Bm16::Slice1R<5u, 3u>(rinstr.low));"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = static_cast<u8>(Bm16::Slice1R<2u, 0u>(rinstr.low));"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm3 = Bm16::Slice1R<8u, 6u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm3);"
                    ]
                }
            },
            "post_block": []
        },
        "sub_immediate_t2": {
            "instruction": "sub_immediate",
            "encoding": "t2",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b00111u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u8 n = static_cast<u8>(Bm16::Slice1R<10u, 8u>(rinstr.low));"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = static_cast<u8>(Bm16::Slice1R<10u, 8u>(rinstr.low));"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": []
        },
        "sub_immediate_t3": {
            "instruction": "sub_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 5u>(rinstr.low)) == 0b01101u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "TRY_ASSIGN(imm32, Instr,Thumb::ThumbExpandImm(imm12));"
                    ]
                }
            },
            "post_block": [
                "assert(!((d == 0xFu) && (S == 1u)) );",
                "if (n == 0b1101u ) {",
                "  return SubSpMinusImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}",
                "if (d == 13u || (d == 15u && S == 0x0u) || n == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sub_immediate_t4": {
            "instruction": "sub_immediate",
            "encoding": "t4",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 4u>(rinstr.low)) == 0b101010u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "assert(Rn != 0b1111u);",
                "if (Rn == 0b1101u) {",
                "    return SubSpMinusImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates); ",
                "}",
                "if (d == 13u || d == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sbc_immediate_t1": {
            "instruction": "sbc_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 5u>(rinstr.low)) == 0b01011u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "TRY_ASSIGN(imm32, Instr,Thumb::ThumbExpandImm(imm12)); "
                    ]
                }
            },
            "post_block": [
                "assert(!((d == 0xFu) && (S == 1u)) );",
                "assert(n!=0xDu );",
                "if (d == 13u || (d == 15u && S == 0x0u) || n == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "add_sp_plus_immediate_t1": {
            "instruction": "add_sp_plus_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b10101u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = static_cast<u8>(Bm16::Slice1R<10u, 8u>(rinstr.low));"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8<<2u);"
                    ]
                }
            },
            "post_block": []
        },
        "add_sp_plus_immediate_t2": {
            "instruction": "add_sp_plus_immediate",
            "encoding": "t2",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 7u>(rinstr.low)) == 0b101100000u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = 13u;"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm7 = Bm16::Slice1R<6u, 0u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm7<<2u);"
                    ]
                }
            },
            "post_block": []
        },
        "add_sp_plus_immediate_t3": {
            "instruction": "add_sp_plus_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 5u>(rinstr.low)) == 0b01000u);",
                "assert((Bm16::Slice1R<3u, 0u>(rinstr.low)) == 0b1101u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "TRY_ASSIGN(imm32, Instr,Thumb::ThumbExpandImm(imm12));"
                    ]
                }
            },
            "post_block": [
                "assert((Rd != 0b1111u) || (S != 1));",
                "if (d == 15u && S == 0x0u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "add_sp_plus_immediate_t4": {
            "instruction": "add_sp_plus_immediate",
            "encoding": "t4",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 0u>(rinstr.low)) == 0b1000001101u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "if (d == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "add_immediate_t1": {
            "instruction": "add_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 9u>(rinstr.low)) == 0b0001110u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u8 n = static_cast<u8>(Bm16::Slice1R<5u, 3u>(rinstr.low));"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = static_cast<u8>(Bm16::Slice1R<2u, 0u>(rinstr.low));"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm3 = Bm16::Slice1R<8u, 6u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm3);"
                    ]
                }
            },
            "post_block": []
        },
        "add_immediate_t2": {
            "instruction": "add_immediate",
            "encoding": "t2",
            "flags": [],
            "pre_block": [],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u8 n = static_cast<u8>(Bm16::Slice1R<10u, 8u>(rinstr.low));"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = static_cast<u8>(Bm16::Slice1R<10u, 8u>(rinstr.low));"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": []
        },
        "add_immediate_t3": {
            "instruction": "add_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 5u>(rinstr.low)) == 0b01000u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0x0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "TRY_ASSIGN(imm32, Instr,Thumb::ThumbExpandImm(imm12));"
                    ]
                }
            },
            "post_block": [
                "assert(!((d == 0xFu) && (S == 1u)) );",
                "if (Rn == 0b1101u) {",
                "    return AddSpPlusImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates); ",
                "}",
                "if (d == 13u || (d == 15u && S == 0x0u) || n == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "add_immediate_t4": {
            "instruction": "add_immediate",
            "encoding": "t4",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0x0u);",
                "assert((Bm16::Slice1R<9u, 5u>(rinstr.low)) == 0b10000u);",
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "assert(Rn != 0b1111u);",
                "if (Rn == 0b1101u) {",
                "    return AddSpPlusImmediateT4Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates); ",
                "}",
                "if (d == 13u || d == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "adc_immediate_t1": {
            "instruction": "adc_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 5u>(rinstr.low)) == 0b01010u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0x0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "TRY_ASSIGN(imm32, Instr,Thumb::ThumbExpandImm(imm12));"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u || n == 13u || n == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "tst_immediate_t1": {
            "instruction": "tst_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 4u>(rinstr.low)) == 0b000001u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);",
                "assert((Bm16::Slice1R<11u, 8u>(rinstr.high)) == 0b1111u);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "TRY_ASSIGN(imm32_carry, Instr,Thumb::ThumbExpandImm_C(imm12, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk));"
                    ]
                }
            },
            "post_block": [
                "if (n == 13u || n == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "teq_immediate_t1": {
            "instruction": "teq_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 4u>(rinstr.low)) == 0b001001u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);",
                "assert((Bm16::Slice1R<11u, 8u>(rinstr.high)) == 0b1111u);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "TRY_ASSIGN(imm32_carry, Instr,Thumb::ThumbExpandImm_C(imm12, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk));"
                    ]
                }
            },
            "post_block": [
                "if (n == 13u || n == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "tst_register_t1": {
            "instruction": "tst_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 6u>(rinstr.low)) == 0b0100001000u);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res = ImmShiftResults{SRType::SRType_LSL, 0u};"
                    ]
                }
            },
            "post_block": []
        },
        "teq_register_t1": {
            "instruction": "teq_register",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111010101001u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);",
                "assert((Bm16::Slice1R<11u, 8u>(rinstr.high)) == 0b1111u);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = static_cast<u32>(Bm16::Slice1R<5u, 4u>(rinstr.high));",
                        "const u32 imm2 = static_cast<u32>(Bm16::Slice1R<7u, 6u>(rinstr.high));",
                        "const u32 imm3 = static_cast<u32>(Bm16::Slice1R<14u, 12u>(rinstr.high));",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2) | imm2);"
                    ]
                }
            },
            "post_block": [
                "if (n == 13u || n == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "and_immediate_t1": {
            "instruction": "and_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);",
                "assert(((Bm16::Slice1R<11u, 8u>(rinstr.high)) != 0b1111u) || ((Bm16::IsolateBit<4u>(rinstr.low)) != 0b1u));",
                "assert((Bm16::Slice1R<9u, 5u>(rinstr.low)) == 0b00000u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "TRY_ASSIGN(imm32_carry, Instr,Thumb::ThumbExpandImm_C(imm12, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk));"
                    ]
                }
            },
            "post_block": [
                "if ( d == 13u || (d == 15u && S == 0u) || n == 13u || n == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "orr_immediate_t1": {
            "instruction": "orr_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 5u>(rinstr.low)) == 0b00010u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "TRY_ASSIGN(imm32_carry, Instr,Thumb::ThumbExpandImm_C(imm12, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk));"
                    ]
                }
            },
            "post_block": [
                "assert(Rn!=0b1111u);",
                "if ( d == 13u || d == 15u || n == 13u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "eor_immediate_t1": {
            "instruction": "eor_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11110u);",
                "assert((Bm16::Slice1R<9u, 5u>(rinstr.low)) == 0b00100u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "TRY_ASSIGN(imm32_carry, Instr,Thumb::ThumbExpandImm_C(imm12, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk));"
                    ]
                }
            },
            "post_block": [
                "if ( d == 13u || (d == 15u && (S == 0u)) || n == 13u || n == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sub_register_t1": {
            "instruction": "sub_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 9u>(rinstr.low)) == 0b0001101u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, 0u};"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u8 m = static_cast<u8>(Bm16::Slice1R<8u, 6u>(rinstr.low));"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u8 n = static_cast<u8>(Bm16::Slice1R<5u, 3u>(rinstr.low));"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = static_cast<u8>(Bm16::Slice1R<2u, 0u>(rinstr.low));"
                    ]
                }
            },
            "post_block": []
        },
        "sub_register_t2": {
            "instruction": "sub_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11101011101u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = static_cast<u32>(Bm16::IsolateBit<4u>(rinstr.low));",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = static_cast<u32>(Bm16::Slice1R<5u, 4u>(rinstr.high));",
                        "const u32 imm2 = static_cast<u32>(Bm16::Slice1R<7u, 6u>(rinstr.high));",
                        "const u32 imm3 = static_cast<u32>(Bm16::Slice1R<14u, 12u>(rinstr.high));",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2) | imm2);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                }
            },
            "post_block": [
                "assert((Rd != 0b1111u) || (S!=1u));",
                "assert(Rn != 0b1101u);",
                "if (d == 13u || (d == 15u && S == 0u) || n == 15u || m == 13u ||m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "rsb_register_t1": {
            "instruction": "rsb_register",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11101011110u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = static_cast<u32>(Bm16::IsolateBit<4u>(rinstr.low));",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = static_cast<u32>(Bm16::Slice1R<5u, 4u>(rinstr.high));",
                        "const u32 imm2 = static_cast<u32>(Bm16::Slice1R<7u, 6u>(rinstr.high));",
                        "const u32 imm3 = static_cast<u32>(Bm16::Slice1R<14u, 12u>(rinstr.high));",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2) | imm2);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u || n == 13u || n == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "umlal_t1": {
            "instruction": "umlal",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110111110u);",
                "assert((Bm16::Slice1R<7u, 4u>(rinstr.high)) == 0b0000u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "dHi": {
                    "decoder": [
                        "const u16 RdHi =  Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 dHi = static_cast<u8>(RdHi);"
                    ]
                },
                "dLo": {
                    "decoder": [
                        "const u16 RdLo = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 dLo = static_cast<u8>(RdLo);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (dLo == 13u || dLo == 15u || dHi == 13u || dHi == 15u || n == 13u || n == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (dHi == dLo) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "umull_t1": {
            "instruction": "umull",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110111010u);",
                "assert((Bm16::Slice1R<7u, 4u>(rinstr.high)) == 0b0000u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "dHi": {
                    "decoder": [
                        "const u16 RdHi =  Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 dHi = static_cast<u8>(RdHi);"
                    ]
                },
                "dLo": {
                    "decoder": [
                        "const u16 RdLo = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 dLo = static_cast<u8>(RdLo);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (dLo == 13u || dLo == 15u || dHi == 13u || dHi == 15u || n == 13u || n == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (dHi == dLo) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "smull_t1": {
            "instruction": "smull",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110111000u);",
                "assert((Bm16::Slice1R<7u, 4u>(rinstr.high)) == 0b0000u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "dHi": {
                    "decoder": [
                        "const u16 RdHi =  Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 dHi = static_cast<u8>(RdHi);"
                    ]
                },
                "dLo": {
                    "decoder": [
                        "const u16 RdLo = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 dLo = static_cast<u8>(RdLo);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (dHi == dLo) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mul_t2": {
            "instruction": "mul",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110110000u);",
                "assert((Bm16::Slice1R<15u, 12u>(rinstr.high)) == 0b1111u);",
                "assert((Bm16::Slice1R<7u, 4u>(rinstr.high)) == 0b0000u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u || n == 13u || n == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "udiv_t1": {
            "instruction": "udiv",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110111011u);",
                "assert((Bm16::Slice1R<15u, 12u>(rinstr.high)) == 0b1111u);",
                "assert((Bm16::Slice1R<7u, 4u>(rinstr.high)) == 0b1111u);"
            ],
            "def": {
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u || n == 13u || n == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sdiv_t1": {
            "instruction": "sdiv",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110111001u);",
                "assert((Bm16::Slice1R<15u, 12u>(rinstr.high)) == 0b1111u);",
                "assert((Bm16::Slice1R<7u, 4u>(rinstr.high)) == 0b1111u);"
            ],
            "def": {
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u || n == 13u || n == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mls_t1": {
            "instruction": "mls",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110110000u);",
                "assert((Bm16::Slice1R<7u, 4u>(rinstr.high)) == 0b0001u);"
            ],
            "def": {
                "a": {
                    "decoder": [
                        "const u16 Ra = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 a = static_cast<u8>(Ra);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u || n == 13u || n == 15u || m == 13u || m == 15u || (a == 13u) || (a == 15u)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mla_t1": {
            "instruction": "mla",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110110000u);",
                "assert((Bm16::Slice1R<7u, 4u>(rinstr.high)) == 0b0000u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "a": {
                    "decoder": [
                        "const u16 Ra = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 a = static_cast<u8>(Ra);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "assert(Ra!=0b1111u);",
                "if (d == 13u || d == 15u || n == 13u || n == 15u || m == 13u || m == 15u || (a == 13u) || (a == 15u)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "add_register_t1": {
            "instruction": "add_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 9u>(rinstr.low)) == 0b0001100u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, 0u};"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u8 m = static_cast<u8>(Bm16::Slice1R<8u, 6u>(rinstr.low));"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u8 n = static_cast<u8>(Bm16::Slice1R<5u, 3u>(rinstr.low));"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u8 d = static_cast<u8>(Bm16::Slice1R<2u, 0u>(rinstr.low));"
                    ]
                }
            },
            "post_block": []
        },
        "add_register_t2": {
            "instruction": "add_register",
            "encoding": "t2",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<10u, 8u>(rinstr.low)) == 0b100u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kSetFlags);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, 0u};"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u8 m = static_cast<u8>(Bm16::Slice1R<6u, 3u>(rinstr.low));"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u32 dn_1 = Bm16::IsolateBit<7u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(dn_1<<3u | Bm16::Slice1R<2u, 0u>(rinstr.low));"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u32 dn_2 = Bm16::IsolateBit<7u>(rinstr.low);",
                        "const u8 d = static_cast<u8>(dn_2<<3u | Bm16::Slice1R<2u, 0u>(rinstr.low));"
                    ]
                }
            },
            "post_block": [
                "assert(d != 0b1101u);",
                "assert(n != 0b1101u);",
                "if (d == 15u &&  TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (d == 15u && m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "add_register_t3": {
            "instruction": "add_register",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11101011000u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                        "const u32 imm2 = Bm16::Slice1R<7u, 6u>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2) | imm2);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                }
            },
            "post_block": [
                "assert((d != 0b1111u) || (S!=1u));",
                "assert(m != 0b1101u);",
                "if (d == 13u || (d == 15u && S == 0u) || n == 15u || m == 13u ||m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "adc_register_t1": {
            "instruction": "adc_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 6u>(rinstr.low)) == 0b0100000101u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res = ImmShiftResults{SRType::SRType_LSL, static_cast<u8>(0u)};"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                }
            },
            "post_block": []
        },
        "adc_register_t2": {
            "instruction": "adc_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11101011010u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                        "const u32 imm2 = Bm16::Slice1R<7u, 6u>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2) | imm2);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u || n == 13u || n == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "stmdb_t1": {
            "instruction": "stmdb",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert(false); // not implemented",
                "assert((Bm16::Slice1R<15u, 6u>(rinstr.low)) == 0b1110100100u);",
                "assert((Bm16::IsolateBit<4u>(rinstr.low)) == 0b0u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);",
                "assert((Bm16::IsolateBit<13u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<5u>(rinstr.low);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u32 M = Bm16::IsolateBit<14u>(rinstr.high);",
                        "const u32 register_list = Bm16::Slice1R<12u, 0u>(rinstr.high);",
                        "const u32 registers = (M<<14u) | register_list;"
                    ]
                }
            },
            "post_block": [
                "assert( (W != 0x1u) || (Rn != 0b1101u) );",
                "if (n == 15 || (Bm32::BitCount(registers) < 2u)) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                " // if wback && registers<n> == '1' then UNPREDICTABLE;"
            ]
        },
        "push_t1": {
            "instruction": "push",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<10u, 9u>(rinstr.low)) == 0b10u);"
            ],
            "def": {
                "UnalignedAllow": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kUnalignedAllow);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u32 M = Bm16::IsolateBit<8u>(rinstr.low);",
                        "const u32 register_list = Bm16::Slice1R<7u, 0u>(rinstr.low);",
                        "const u32 registers = (M<<14u) | register_list;"
                    ]
                }
            },
            "post_block": [
                "if (Bm32::BitCount(registers) < 1u) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "push_t2": {
            "instruction": "push",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 0u>(rinstr.low)) == 0b1110100100101101u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);",
                "assert((Bm16::IsolateBit<13u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "UnalignedAllow": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kUnalignedAllow);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u32 M = Bm16::IsolateBit<14u>(rinstr.high);",
                        "const u32 register_list = Bm16::Slice1R<12u, 0u>(rinstr.high);",
                        "const u32 registers = (M<<14u) | register_list;"
                    ]
                }
            },
            "post_block": [
                "if (Bm32::BitCount(registers) < 2u) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "push_t3": {
            "instruction": "push",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert(rinstr.low == 0b1111100001001101u);",
                "assert((Bm16::Slice1R<11u, 0u>(rinstr.high)) == 0b110100000100u);"
            ],
            "def": {
                "UnalignedAllow": {
                    "flag_decoder": [
                        "flags |=  static_cast<InstrFlagsSet>(InstrFlags::kUnalignedAllow);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);",
                        "const u32 registers = 1u << Rt;"
                    ]
                }
            },
            "post_block": [
                "if (t==13u || t==15u) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldm_t1": {
            "instruction": "ldm",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11001u);"
            ],
            "def": {
                "wback": {
                    "flag_decoder": [
                        "const u8 Rn_flag = static_cast<u8>(Bm16::Slice1R<10u, 8u>(rinstr.low));",
                        "const u16 register_list_flag = Bm16::Slice1R<7u, 0u>(rinstr.low);",
                        "const u16 n_mask = 1u << Rn_flag;",
                        "flags |= (register_list_flag&n_mask) == 0 ? static_cast<InstrFlagsSet>(InstrFlags::kWBack):0u;"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u16 register_list = Bm16::Slice1R<7u, 0u>(rinstr.low);",
                        "const u32 registers = static_cast<u32>(register_list);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<10u, 8u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (Bm32::BitCount(registers) < 1u) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldm_t2": {
            "instruction": "ldm",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 6u>(rinstr.low)) == 0b1110100010u);",
                "assert((Bm16::IsolateBit<4u>(rinstr.low)) == 0b1u);",
                "assert((Bm16::IsolateBit<13u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<5u>(rinstr.low);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u32 P = Bm16::IsolateBit<15u>(rinstr.high);",
                        "const u32 M = Bm16::IsolateBit<14u>(rinstr.high);",
                        "const u32 register_list = Bm16::Slice1R<12u, 0u>(rinstr.high);",
                        "const u32 registers = (P<<15u) | (M<<14u) | register_list;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "assert((W!=1) || (Rn!=0b1101u));",
                "if (n == 15 || (Bm32::BitCount(registers) < 2u) || ((P == 1u) && M == 1u)) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if ((Bm32::Slice1R<15u, 15u>(registers) == 0x1u) && ( TItOps::InITBlock(pstates)) && (! TItOps::LastInITBlock(pstates))) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (flags & static_cast<InstrFlagsSet>(InstrFlags::kWBack) && ( (registers &(1<<n)) != 0u)) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "stm_t1": {
            "instruction": "stm",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b11000u);"
            ],
            "def": {
                "wback": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u16 register_list = Bm16::Slice1R<7u, 0u>(rinstr.low);",
                        "const u32 registers =  static_cast<u32>(register_list);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<10u, 8u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": []
        },
        "stm_t2": {
            "instruction": "stm",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 6u>(rinstr.low)) == 0b1110100010u);",
                "assert((Bm16::IsolateBit<4u>(rinstr.low)) == 0b0u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);",
                "assert((Bm16::IsolateBit<13u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "UnalignedAllow": {
                    "flag_decoder": [
                        "flags &=  ~static_cast<InstrFlagsSet>(InstrFlags::kUnalignedAllow);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<5u>(rinstr.low);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "registers": {
                    "decoder": [
                        "const u32 M = Bm16::IsolateBit<14u>(rinstr.high);",
                        "const u32 register_list = Bm16::Slice1R<12u, 0u>(rinstr.high);",
                        "const u32 registers = (M<<14u) | register_list;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                }
            },
            "post_block": [
                "if (n == 15 || (Bm32::BitCount(registers) < 2u)){",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (flags&static_cast<InstrFlagsSet>(InstrFlags::kWBack) && ( (registers &(1<<n)) != 0u)) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sxth_t1": {
            "instruction": "sxth",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 6u>(rinstr.low)) == 0b1011001000u);"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "rotation": {
                    "decoder": [
                        "const u8 rotation = 0u;"
                    ]
                }
            },
            "post_block": []
        },
        "sxth_t2": {
            "instruction": "sxth",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 0u>(rinstr.low)) == 0b1111101000001111u);",
                "assert((Bm16::Slice1R<15u, 12u>(rinstr.high)) == 0b1111u);",
                "assert((Bm16::Slice1R<7u, 6u>(rinstr.high)) == 0b10u);"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "rotation": {
                    "decoder": [
                        "const u16 rotate = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                        "const u8 rotation = static_cast<u8>(rotate<<3u);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "uxtb_t1": {
            "instruction": "uxtb",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<11u, 6u>(rinstr.low)) == 0b001011u);"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "rotation": {
                    "decoder": [
                        "const u8 rotation = 0u;"
                    ]
                }
            },
            "post_block": []
        },
        "uxtb_t2": {
            "instruction": "uxtb",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 0u>(rinstr.low)) == 0b1111101001011111u);",
                "assert((Bm16::Slice1R<15u, 12u>(rinstr.high)) == 0b1111u);",
                "assert((Bm16::Slice1R<7u, 6u>(rinstr.high)) == 0b10u);"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "rotation": {
                    "decoder": [
                        "const u32 rotate = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                        "const u8 rotation = static_cast<u8>(rotate<<3u);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sxtb_t1": {
            "instruction": "sxtb",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 6u>(rinstr.low)) == 0b1011001001u);"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "rotation": {
                    "decoder": [
                        "const u8 rotation = 0u;"
                    ]
                }
            },
            "post_block": []
        },
        "sxtb_t2": {
            "instruction": "sxtb",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 0u>(rinstr.low)) == 0b1111101001001111u);",
                "assert((Bm16::Slice1R<15u, 12u>(rinstr.high)) == 0b1111u);",
                "assert((Bm16::Slice1R<7u, 6u>(rinstr.high)) == 0b10u);"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "rotation": {
                    "decoder": [
                        "const u16 rotate = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                        "const u8 rotation = static_cast<u8>(rotate<<3u);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "uxth_t1": {
            "instruction": "uxth",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 6u>(rinstr.low)) == 0b1011001010u);"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "rotation": {
                    "decoder": [
                        "const u8 rotation = 0u;"
                    ]
                }
            },
            "post_block": []
        },
        "uxth_t2": {
            "instruction": "uxth",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 0u>(rinstr.low)) == 0b1111101000011111u);",
                "assert((Bm16::Slice1R<15u, 12u>(rinstr.high)) == 0b1111u);",
                "assert((Bm16::Slice1R<7u, 6u>(rinstr.high)) == 0b10u);"
            ],
            "def": {
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "rotation": {
                    "decoder": [
                        "const u32 rotate = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                        "const u8 rotation = rotate<<3u;"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "bfi_t1": {
            "instruction": "bfi",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111100110110u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);",
                "assert((Bm16::IsolateBit<5u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "lsbit": {
                    "decoder": [
                        "const u32 imm2 = static_cast<u32>(Bm16::Slice1R<7u, 6u>(rinstr.high));",
                        "const u32 imm3 = static_cast<u32>(Bm16::Slice1R<14u, 12u>(rinstr.high));",
                        "const u8 lsbit = static_cast<u8>((imm3<<2u)| imm2);"
                    ]
                },
                "msbit": {
                    "decoder": [
                        "const u16 msb = Bm16::Slice1R<4u, 0u>(rinstr.high);",
                        "const u8 msbit = static_cast<u8>(msb);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u || n == 13u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ubfx_t1": {
            "instruction": "ubfx",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111100111100u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);",
                "assert((Bm16::IsolateBit<5u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "lsbit": {
                    "decoder": [
                        "const u32 imm2 = Bm16::Slice1R<7u, 6u>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u8 lsbit = static_cast<u8>((imm3<<2u)| imm2);"
                    ]
                },
                "widthminus1": {
                    "decoder": [
                        "const u32 widthm1 = Bm16::Slice1R<4u, 0u>(rinstr.high);",
                        "const u8 widthminus1 = static_cast<u8>(widthm1);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u || n == 13u || n == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "eor_register_t1": {
            "instruction": "eor_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 6u>(rinstr.low)) == 0b0100000001u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "// TODO: use ImmShiftResults for all occureces",
                        "const auto shift_res = Alu32::DecodeImmShift(0b00, 0);"
                    ]
                }
            },
            "post_block": []
        },
        "eor_register_t2": {
            "instruction": "eor_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11101010100u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                        "const u32 imm2 = Bm16::Slice1R<7u, 6u>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2u) | imm2);"
                    ]
                }
            },
            "post_block": [
                "assert((Rd!=0b1111u) || (S!=1));",
                "if (d == 13u || (d == 15u && (S == 0)) || n == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "sbc_register_t2": {
            "instruction": "sbc_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11101011011u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                        "const u32 imm2 = Bm16::Slice1R<7u, 6u>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2u) | imm2);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u ||n == 13u || n == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "orr_register_t1": {
            "instruction": "orr_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 6u>(rinstr.low)) == 0b0100001100u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res = Alu32::DecodeImmShift(0b00, 0);"
                    ]
                }
            },
            "post_block": []
        },
        "orr_register_t2": {
            "instruction": "orr_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11101010010u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                        "const u32 imm2 = Bm16::Slice1R<7u, 6u>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2u) | imm2);"
                    ]
                }
            },
            "post_block": [
                "assert(Rn!=0b1111u);",
                "if (d == 13u || d == 15u || n == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "and_register_t1": {
            "instruction": "and_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 6u>(rinstr.low)) == 0b0100000000u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res = Alu32::DecodeImmShift(0b00, 0);"
                    ]
                }
            },
            "post_block": []
        },
        "and_register_t2": {
            "instruction": "and_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11101010000u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                        "const u32 imm2 = Bm16::Slice1R<7u, 6u>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2u) | imm2);"
                    ]
                }
            },
            "post_block": [
                "assert((Rd!=0b1111u) || (S!=0b1u));",
                "if (d == 13u || (d == 15u && (S == 0u)) || n == 13u || n == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "bic_immediate_t1": {
            "instruction": "bic_immediate",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<9u, 5u>(rinstr.low)) == 0b00001u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "imm32_carry": {
                    "decoder": [
                        "const u32 i = Bm16::IsolateBit<10u>(rinstr.low);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm12 = (i << 11u) | (imm3 << 8u) | imm8;",
                        "auto apsr = TSpecRegOps::template ReadRegister<SpecialRegisterId::kApsr>(pstates);",
                        "TRY_ASSIGN(imm32_carry, Instr,Thumb::ThumbExpandImm_C(imm12, (apsr & ApsrRegister::kCMsk) == ApsrRegister::kCMsk));"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u || n == 13u|| n == 15u){",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "bic_register_t1": {
            "instruction": "bic_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 6u>(rinstr.low)) == 0b0100001110u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, 0u};"
                    ]
                }
            },
            "post_block": []
        },
        "bic_register_t2": {
            "instruction": "bic_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11101010001u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 type = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                        "const u32 imm2 = Bm16::Slice1R<7u, 6u>(rinstr.high);",
                        "const u32 imm3 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2u) | imm2);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u || n == 13u || n == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "lsr_register_t1": {
            "instruction": "lsr_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 6u>(rinstr.low)) == 0b0100000011u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": []
        },
        "lsr_register_t2": {
            "instruction": "lsr_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11111010001u);",
                "assert((Bm16::Slice1R<15u, 12u>(rinstr.high)) == 0b1111u);",
                "assert((Bm16::Slice1R<7u, 4u>(rinstr.high)) == 0b0000u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15 || n == 13u || n == 15 || m == 13u || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "asr_register_t1": {
            "instruction": "asr_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 6u>(rinstr.low)) == 0b0100000100u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": []
        },
        "asr_register_t2": {
            "instruction": "asr_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11111010010u);",
                "assert((Bm16::Slice1R<15u, 12u>(rinstr.high)) == 0b1111u);",
                "assert((Bm16::Slice1R<7u, 4u>(rinstr.high)) == 0b0000u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15 || n == 13u || n == 15 || m == 13u || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "lsr_immediate_t1": {
            "instruction": "lsr_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b00001u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "flags |=  TItOps::InITBlock(pstates) == false? static_cast<InstrFlagsSet>(InstrFlags::kSetFlags):0u;"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<10u, 6u>(rinstr.low);",
                        "const auto shift_res = Alu32::DecodeImmShift(0b01u, imm5);"
                    ]
                }
            },
            "post_block": []
        },
        "lsr_immediate_t2": {
            "instruction": "lsr_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11101010010u);",
                "assert((Bm16::Slice1R<3u, 0u>(rinstr.low)) == 0b1111u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);",
                "assert((Bm16::Slice1R<5u, 4u>(rinstr.high)) == 0b01u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm3_32 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm2_32 = Bm16::Slice1R<7u, 6u>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(0b01u, (imm3_32<<2u) | imm2_32);"
                    ]
                }
            },
            "post_block": [
                "assert(shift_res.type == SRType::SRType_LSR);",
                "if (d == 13u || d == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mvn_register_t2": {
            "instruction": "mvn_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11101010011u);",
                "assert((Bm16::Slice1R<3u, 0u>(rinstr.low)) == 0b1111u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm3 = static_cast<u32>(Bm16::Slice1R<14u, 12u>(rinstr.high));",
                        "const u32 imm2 = static_cast<u32>(Bm16::Slice1R<7u, 6u>(rinstr.high));",
                        "const u32 type = static_cast<u32>(Bm16::Slice1R<5u, 4u>(rinstr.high));",
                        "const auto shift_res = Alu32::DecodeImmShift(type, (imm3<<2u) | imm2);"
                    ]
                }
            },
            "post_block": [
                "if (d == 13u || d == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "asr_immediate_t2": {
            "instruction": "asr_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 5u>(rinstr.low)) == 0b11101010010u);",
                "assert((Bm16::Slice1R<3u, 0u>(rinstr.low)) == 0b1111u);",
                "assert((Bm16::IsolateBit<15u>(rinstr.high)) == 0b0u);",
                "assert((Bm16::Slice1R<5u, 4u>(rinstr.high)) == 0b10u);"
            ],
            "def": {
                "setflags": {
                    "flag_decoder": [
                        "const u32 S = Bm16::IsolateBit<4u>(rinstr.low);",
                        "flags |= S << static_cast<InstrFlagsSet>(InstrFlagsShift::kSetFlagsShift);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d  = static_cast<u8>(Rd);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm3_32 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                        "const u32 imm2_32 = Bm16::Slice1R<7u, 6u>(rinstr.high);",
                        "const auto shift_res = Alu32::DecodeImmShift(0b10u, (imm3_32<<2u) | imm2_32);"
                    ]
                }
            },
            "post_block": [
                "assert(shift_res.type == SRType::SRType_ASR);",
                "if (d == 13u || d == 15u || m == 13u || m == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "str_register_t1": {
            "instruction": "str_register",
            "encoding": "t1",
            "pre_block": [
                "assert((Bm16::Slice1R<15U, 9U>(rinstr.low)) == 0b0101000u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<8u, 6u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res = ImmShiftResults{SRType::SRType_LSL, 0u};"
                    ]
                }
            },
            "post_block": []
        },
        "str_register_t2": {
            "instruction": "str_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110000100u);",
                "assert((Bm16::Slice1R<11u, 6u>(rinstr.high)) == 0b000000u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm2 = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, static_cast<u8>(imm2)};"
                    ]
                }
            },
            "post_block": [
                "if (t == 15u || m == 13u || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "strb_register_t1": {
            "instruction": "strb_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 9u>(rinstr.low)) == 0b0101010u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<8u, 6u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res = ImmShiftResults{SRType::SRType_LSL, 0u};"
                    ]
                }
            },
            "post_block": []
        },
        "strb_register_t2": {
            "instruction": "strb_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110000000u);",
                "assert((Bm16::Slice1R<11u, 6u>(rinstr.high)) == 0b000000u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm2 = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, static_cast<u8>(imm2)};"
                    ]
                }
            },
            "post_block": [
                "if (Rn == 0b1111u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 13u || t == 15u || m == 13u || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "strh_register_t2": {
            "instruction": "strh_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110000010u);",
                "assert((Bm16::Slice1R<11u, 6u>(rinstr.high)) == 0b000000u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm2 = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, static_cast<u8>(imm2)};"
                    ]
                }
            },
            "post_block": [
                "if (Rn == 0b1111u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 13u || t == 15u || m == 13u || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrb_register_t1": {
            "instruction": "ldrb_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 9u>(rinstr.low)) == 0b0101110u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<8u, 6u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, 0x0u};"
                    ]
                }
            },
            "post_block": []
        },
        "ldr_register_t1": {
            "instruction": "ldr_register",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 9u>(rinstr.low)) == 0b0101100u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<8u, 6u>(rinstr.low);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const auto shift_res = ImmShiftResults{SRType::SRType_LSL, 0x0u};"
                    ]
                }
            },
            "post_block": []
        },
        "ldr_register_t2": {
            "instruction": "ldr_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110000101u);",
                "assert((Bm16::Slice1R<11u, 6u>(rinstr.high)) == 0b000000u);",
                "assert((Bm16::Slice1R<3u, 0u>(rinstr.low)) != 0b1111u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm2 = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, static_cast<u8>(imm2)};"
                    ]
                }
            },
            "post_block": [
                "if (m == 13u || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (t == 15u &&  TItOps::InITBlock(pstates) && ! TItOps::LastInITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "ldrh_register_t2": {
            "instruction": "ldrh_register",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110000011u);",
                "assert((Bm16::Slice1R<11u, 6u>(rinstr.high)) == 0b000000u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "m": {
                    "decoder": [
                        "const u16 Rm = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                        "const u8 m = static_cast<u8>(Rm);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "shift_res": {
                    "decoder": [
                        "const u32 imm2 = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                        "const auto shift_res =ImmShiftResults{SRType::SRType_LSL, static_cast<u8>(imm2)};"
                    ]
                }
            },
            "post_block": [
                "assert(Rn!=0b1111u);",
                "assert(Rt!=0b1111u);",
                "if (t == 13u || m == 13u || m == 15) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "strd_immediate_t1": {
            "instruction": "strd_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 9u>(rinstr.low)) == 0b1110100u);",
                "assert((Bm16::IsolateBit<6u>(rinstr.low)) == 0b1u);",
                "assert((Bm16::IsolateBit<4u>(rinstr.low)) == 0b0u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<7u>(rinstr.low);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = Bm16::IsolateBit<8u>(rinstr.low);",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<5u>(rinstr.low);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "t2": {
                    "decoder": [
                        "const u16 Rt2 = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 t2 = static_cast<u8>(Rt2);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8_32 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8_32<<2u);"
                    ]
                }
            },
            "post_block": [
                "assert((P!=0u) || (W!=0u));",
                "if (flags&static_cast<InstrFlagsSet>(InstrFlags::kWBack) && (n == t || n == t2)) { ",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if (n == 15u ||t == 13u || t == 15u || t2 == 13u || t2 == 15u) { ",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "strh_immediate_t1": {
            "instruction": "strh_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b10000u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<10u, 6u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm5<<1u);"
                    ]
                }
            },
            "post_block": []
        },
        "strh_immediate_t2": {
            "instruction": "strh_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110001010u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "if (t == 13u || t == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "strh_immediate_t3": {
            "instruction": "strh_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110000010u);",
                "assert((Bm16::IsolateBit<11u>(rinstr.high)) == 0b1u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<9u>(rinstr.high);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = Bm16::IsolateBit<10u>(rinstr.high);",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<8u>(rinstr.high);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": [
                "assert (P!=0b1u || U!=0b1u || W!=0b0u);",
                "if ((Rn == 0b1111u) || (P == 0b0 && W == 0b0u) ) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if ((t == 13u || t == 15u) && (flags&static_cast<InstrFlagsSet>(InstrFlags::kWBack) && n == t)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "strb_immediate_t1": {
            "instruction": "strb_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b01110u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<10u, 6u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm5);"
                    ]
                }
            },
            "post_block": []
        },
        "strb_immediate_t2": {
            "instruction": "strb_immediate",
            "encoding": "t2",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110001000u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "if (Rn == 0b1111u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 13u || t == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "strb_immediate_t3": {
            "instruction": "strb_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110000000u);",
                "assert((Bm16::IsolateBit<11u>(rinstr.high)) == 0b1u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<9u>(rinstr.high);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = Bm16::IsolateBit<10u>(rinstr.high);",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<8u>(rinstr.high);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": [
                "assert((P!=1u) ||(U!=1) || (W!=0u)) ;",
                "if (n == 15u || ((P == 0u) && (W == 0u))) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 13u || t == 15u || (flags&static_cast<InstrFlagsSet>(InstrFlags::kWBack) && n == t)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "str_immediate_t1": {
            "instruction": "str_immediate",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b01100u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<5u, 3u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<10u, 6u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm5<<2);"
                    ]
                }
            },
            "post_block": []
        },
        "str_immediate_t2": {
            "instruction": "str_immediate",
            "encoding": "t2",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 11u>(rinstr.low)) == 0b10010u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u8 n = 13u;"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<10u, 8u>(rinstr.low);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8<<2u);"
                    ]
                }
            },
            "post_block": []
        },
        "str_immediate_t3": {
            "instruction": "str_immediate",
            "encoding": "t3",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110001100u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t  = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm12 = Bm16::Slice1R<11u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm12);"
                    ]
                }
            },
            "post_block": [
                "if (n == 0b1111u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 15u) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "str_immediate_t4": {
            "instruction": "str_immediate",
            "encoding": "t4",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111110000100u);",
                "assert((Bm16::IsolateBit<11u>(rinstr.high)) == 0b1u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "const u32 U = Bm16::IsolateBit<9u>(rinstr.high);",
                        "flags |= U << static_cast<InstrFlagsSet>(InstrFlagsShift::kAddShift);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "const u32 P = Bm16::IsolateBit<10u>(rinstr.high);",
                        "flags |= P << static_cast<InstrFlagsSet>(InstrFlagsShift::kIndexShift);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "const u32 W = Bm16::IsolateBit<8u>(rinstr.high);",
                        "flags |= W << static_cast<InstrFlagsSet>(InstrFlagsShift::kWBackShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8_32 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8_32);"
                    ]
                }
            },
            "post_block": [
                "assert((P!=1u) ||(U!=1) || (W!=0u)) ;",
                "if ((n==13u) && (P==1) && (U==0u) && (W==1u) && (imm8_32==0b00000100u)) {",
                "  return PushT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}",
                "if (n == 15u || ((P == 0u) && (W == 0u))) {",
                "  return Err<Instr>(StatusCode::kScDecoderUndefined);",
                "}",
                "if (t == 15u || (flags&static_cast<InstrFlagsSet>(InstrFlags::kWBack) && n == t)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "strex_t1": {
            "instruction": "strex",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111010000100u);"
            ],
            "def": {
                "add": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kAdd);"
                    ]
                },
                "index": {
                    "flag_decoder": [
                        "flags |= static_cast<InstrFlagsSet>(InstrFlags::kIndex);"
                    ]
                },
                "wback": {
                    "flag_decoder": [
                        "flags &=~static_cast<InstrFlagsSet>(InstrFlags::kWBack);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "t": {
                    "decoder": [
                        "const u16 Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                        "const u8 t = static_cast<u8>(Rt);"
                    ]
                },
                "d": {
                    "decoder": [
                        "const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                        "const u8 d = static_cast<u8>(Rd);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm8_32 = Bm16::Slice1R<7u, 0u>(rinstr.high);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8_32);"
                    ]
                }
            },
            "post_block": [
                "if (d == n || d == t) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "cb_n_z_t1": {
            "instruction": "cb_n_z",
            "encoding": "t1",
            "flags": [],
            "pattern": {
                "lo": "1011x0xxxxxxxxxx",
                "hi": "0xxxxxxxxxxxxxxx"
            },
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 12u>(rinstr.low)) == 0b1011u);",
                "assert((Bm16::IsolateBit<10u>(rinstr.low)) == 0b0u);",
                "assert((Bm16::IsolateBit<8u>(rinstr.low)) == 0b1u);"
            ],
            "def": {
                "nonzero": {
                    "flag_decoder": [
                        "const u32 op = Bm16::IsolateBit<11u>(rinstr.low);",
                        "flags |= op << static_cast<InstrFlagsSet>(InstrFlagsShift::kNonZeroShift);"
                    ]
                },
                "n": {
                    "decoder": [
                        "const u16 Rn = Bm16::Slice1R<2u, 0u>(rinstr.low);",
                        "const u8 n = static_cast<u8>(Rn);"
                    ]
                },
                "imm32": {
                    "decoder": [
                        "const u32 imm5 = Bm16::Slice1R<7u, 3u>(rinstr.low);",
                        "const u32 i = Bm16::IsolateBit<9u>(rinstr.low);",
                        "const i32 imm32 = Bm32::ZeroExtend<u32>((i<<6u) | (imm5<<1u));"
                    ]
                }
            },
            "post_block": [
                "if ( TItOps::InITBlock(pstates)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "svc_t1": {
            "instruction": "svc",
            "encoding": "t1",
            "flags": [],
            "pattern": {
                "lo": "11011111xxxxxxxx"
            },
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 8u>(rinstr.low)) == 0b11011111u);"
            ],
            "def": {
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": []
        },
        "bkpt_t1": {
            "instruction": "bkpt",
            "encoding": "t1",
            "flags": [],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 8u>(rinstr.low)) == 0b10111110u);"
            ],
            "def": {
                "imm32": {
                    "decoder": [
                        "const u32 imm8 = Bm16::Slice1R<7u, 0u>(rinstr.low);",
                        "const u32 imm32 = Bm32::ZeroExtend<u32>(imm8);"
                    ]
                }
            },
            "post_block": []
        },
        "msr_t1": {
            "instruction": "msr",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert((Bm16::Slice1R<15u, 4u>(rinstr.low)) == 0b111100111000u);",
                "assert((Bm16::Slice1R<15u, 12u>(rinstr.high)) == 0b1000u);",
                "assert((Bm16::Slice1R<9u, 8u>(rinstr.high)) == 0b00u);"
            ],
            "def": {
                "n": {
                    "decoder": [
                        "const u8 n = static_cast<u8>(Bm16::Slice1R<3u, 0u>(rinstr.low));"
                    ]
                },
                "mask": {
                    "decoder": [
                        "const u8 mask = static_cast<u8>(Bm16::Slice1R<11u, 10u>(rinstr.high));"
                    ]
                },
                "SYSm": {
                    "decoder": [
                        "const u8 SYSm = static_cast<u8>(Bm16::Slice1R<7u, 0u>(rinstr.high));"
                    ]
                }
            },
            "post_block": [
                "if (mask == 0b00u || (mask != 0b10U && !(SYSm == 0u || SYSm==1u || SYSm==2u || SYSm==3u))) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}",
                "if ((n==13u) || (n==15u) || !(SYSm == 0u || SYSm==1u || SYSm==2u || SYSm==3u || SYSm==5u || SYSm==6u || SYSm==7u || SYSm==8u || SYSm==9u || SYSm==16u || SYSm==17u || SYSm==18u || SYSm==19u || SYSm==20u)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        },
        "mrs_t1": {
            "instruction": "mrs",
            "encoding": "t1",
            "flags": [
                "32bit"
            ],
            "pre_block": [
                "assert(rinstr.low == 0b1111001111101111u);",
                "assert((Bm16::Slice1R<15u, 12u>(rinstr.high)) == 0b1000u);"
            ],
            "def": {
                "d": {
                    "decoder": [
                        "const u8 d = static_cast<u8>(Bm16::Slice1R<11u, 8u>(rinstr.high));"
                    ]
                },
                "mask": {
                    "decoder": [
                        "const u8 mask = static_cast<u8>(Bm16::Slice1R<11u, 10u>(rinstr.high));"
                    ]
                },
                "SYSm": {
                    "decoder": [
                        "const u8 SYSm = static_cast<u8>(Bm16::Slice1R<7u, 0u>(rinstr.high));"
                    ]
                }
            },
            "post_block": [
                "if ((d==13u) || (d==15u) || !(SYSm == 0u || SYSm==1u || SYSm==2u || SYSm==3u || SYSm==5u || SYSm==6u || SYSm==7u || SYSm==8u || SYSm==9u || SYSm==16u || SYSm==17u || SYSm==18u || SYSm==19u || SYSm==20u)) {",
                "  return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "}"
            ]
        }
    },
    "splitters": {
        "16bit_op00000": {
            "flags": [],
            "splitters": [
                "// # 16-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p129",
                "// ",
                "// # Shift (immediate), add, subtract, move, and compare",
                "const u16 opcode = Bm16::Slice1R<13u, 9u>(rinstr.low);",
                "if (Bm16::Slice1R<4u, 2u>(opcode) == 0b000u) {",
                "  if (Bm16::Slice1R<10u, 6u>(rinstr.low) == 0b00000u) {",
                "    return MovRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else {",
                "    return LslImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "}"
            ]
        },
        "16bit_op00011": {
            "flags": [],
            "splitters": [
                "// # 16-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p129",
                "// ",
                "// # Shift (immediate), add, subtract, move, and compare",
                "//  see Armv7-M Architecture Reference Manual Issue E.e p130",
                "const u16 opcode = Bm16::Slice1R<13u, 9u>(rinstr.low);",
                "if (opcode == 0b01100u) {",
                "  return AddRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}  else if (opcode == 0b01110u) {",
                "  return AddImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (opcode == 0b01101u) {",
                "  return SubRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (opcode == 0b01111u) {",
                "  return SubImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}"
            ]
        },
        "16bit_op01010": {
            "flags": [],
            "splitters": [
                "// # Load/store single data item",
                "// see Armv7-M Architecture Reference Manual Issue E.e p133",
                "// ",
                "const u16 op_a = Bm16::Slice1R<15u, 12u>(rinstr.low);",
                "const u16 op_b = Bm16::Slice1R<11u, 9u>(rinstr.low);",
                "if (op_a == 0b0101U && op_b == 0b000U) {",
                "   return StrRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (op_a == 0b0101U && op_b == 0b010U) {",
                "  return StrbRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}"
            ]
        },
        "16bit_op10111": {
            "flags": [],
            "splitters": [
                "// # Miscellaneous 16-bit instructions",
                "// see Armv7-M Architecture Reference Manual Issue E.e p134",
                "// ",
                "const u16 opcode = Bm16::Slice1R<11u, 5u>(rinstr.low);",
                "if (Bm16::Slice1R<6u, 3u>(opcode) == 0b1001u) {",
                "  return CbNZT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6u, 3u>(opcode) == 0b1011u) {",
                "  return CbNZT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6u, 4u>(opcode) == 0b110u) {",
                "  return PopT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6u, 3u>(opcode) == 0b1110u) {",
                "  return BkptT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6u, 3u>(opcode) == 0b1111u) {",
                "  // # If-Then, and hints",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p135",
                "  if (Bm16::Slice1R<3u, 0u>(rinstr.low) != 0x0u) {",
                "    return ItT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "  if ( (Bm16::Slice1R<3u, 0u>(rinstr.low) == 0x0u) && (Bm16::Slice1R<7u, 4u>(rinstr.low) == 0x0u)) {",
                "    return NopT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "}"
            ]
        },
        "16bit_op10110": {
            "flags": [],
            "splitters": [
                "// # 16-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p129",
                "// ",
                "// ## Miscellaneous 16-bit instructions",
                "// see Armv7-M Architecture Reference Manual Issue E.e p134",
                "const u16 opcode = Bm16::Slice1R<11u, 5u>(rinstr.low);",
                "if (Bm16::Slice1R<6u, 2u>(opcode) == 0b00000u) {",
                "   return AddSpPlusImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6u, 3u>(opcode) == 0b0001u) {",
                "   return CbNZT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6u, 2u>(opcode) == 0b00001u) {",
                "   return SubSpMinusImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6u, 3u>(opcode) == 0b0011u) {",
                "  return CbNZT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6u, 1u>(opcode) == 0b001001u) {",
                "  return SxtbT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6u, 1u>(opcode) == 0b001011u) {",
                "  return UxtbT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6u, 1u>(opcode) == 0b001010u) {",
                "    return UxthT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6u, 1u>(opcode) == 0b001000u) {",
                "    return SxthT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (Bm16::Slice1R<6u, 4u>(opcode) == 0b010u) {",
                "    return PushT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}"
            ]
        },
        "16bit_op01000": {
            "flags": [],
            "splitters": [
                "if (Bm16::IsolateBit<10u>(rinstr.low) == 0x1) {",
                "  // ## Special data instructions and branch and exchange",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p132",
                "  if (Bm16::Slice1R<9u, 8u>(rinstr.low) == 0b00u) {",
                "    return AddRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (Bm16::Slice1R<9u, 8u>(rinstr.low) == 0b10u) {",
                "    return MovRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (Bm16::Slice1R<9u, 8u>(rinstr.low) == 0b01u) {",
                "    return CmpRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (Bm16::Slice1R<9u, 7u>(rinstr.low) == 0b110u) {",
                "    return BxT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (Bm16::Slice1R<9u, 7u>(rinstr.low) == 0b111u) {",
                "    return BlxT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "} else {",
                "  // ## Data processing",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p131",
                "  const u16 _opcode = Bm16::Slice1R<9u, 6u>(rinstr.low);",
                "  if (_opcode == 0b0000u) {",
                "    return AndRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b0010u) {",
                "    return LslRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b0011u) {",
                "    return LsrRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b0100u) {",
                "    return AsrRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b0101u) {",
                "    return AdcRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b0001u) {",
                "    return EorRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b1000u) {",
                "    return TstRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b1001u) {",
                "    return RsbImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b1010u) {",
                "    return CmpRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b1100u) {",
                "    return OrrRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_opcode == 0b1110u) {",
                "    return BicRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "}"
            ]
        },
        "16bit_op01011": {
            "flags": [],
            "splitters": [
                "// # 16-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p129",
                "",
                "const u16 opB = Bm16::Slice1R<11u, 9u>(rinstr.low);",
                "// # Load/store single data item",
                "// see Armv7-M Architecture Reference Manual Issue E.e p133",
                "if (opB == 0b100u) {",
                "  return LdrRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (opB == 0b110u) {",
                "  return LdrbRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}"
            ]
        },
        "16bit_op01101": {
            "flags": [],
            "splitters": [
                "// # 16-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p129",
                "",
                "const u16 opB = Bm16::Slice1R<11u, 9u>(rinstr.low);",
                "// # Load/store single data item",
                "// see Armv7-M Architecture Reference Manual Issue E.e p133",
                "if (Bm16::Slice1R<2u, 2u>(opB) == 0b1u) {",
                "  return LdrImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}"
            ]
        },
        "16bit_op11011": {
            "flags": [],
            "splitters": [
                "// # 16-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p129",
                "// ",
                "// ## Conditional branch, and Supervisor Call",
                "// see Armv7-M Architecture Reference Manual Issue E.e p136",
                "const u16 opcode = Bm16::Slice1R<11u, 8u>(rinstr.low);",
                "if (Bm16::Slice1R<3u, 1u>(opcode) != 0b111u) {",
                "  return BT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "} else if (opcode == 0b1111u) {",
                "  return SvcT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "}"
            ]
        },
        "32bit_op11101": {
            "flags": [
                "32bit"
            ],
            "splitters": [
                "// # 32-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p137",
                "if (Bm16::Slice1R<10u, 9u>(rinstr.low) == 0b01u) {",
                "  // ## Data processing (shifted register)",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p150",
                "  const u16 op = Bm16::Slice1R<8u, 5u>(rinstr.low);",
                "  const u16 Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                "  const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                "  const u16 S = Bm16::IsolateBit<4u>(rinstr.low);",
                "  if ((op == 0b0000u) && (Rd != 0b1111u)) {",
                "    return AndRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b0001u)   {",
                "    return BicRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b0011u && Rn == 0b1111u) {",
                "    return MvnRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b1000u && Rd != 0b1111u) {",
                "    return AddRegisterT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b1110u) {",
                "    return RsbRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b0010u && Rn == 0b1111u) {",
                "    // ### Move register and immediate shifts",
                "    // see Armv7-M Architecture Reference Manual Issue E.e p151",
                "    const u32 type = static_cast<u32>(Bm16::Slice1R<5u, 4u>(rinstr.high));",
                "    const u32 imm2 = static_cast<u32>(Bm16::Slice1R<7u, 6u>(rinstr.high));",
                "    const u32 imm3 = static_cast<u32>(Bm16::Slice1R<14u, 12u>(rinstr.high));",
                "    const u32 imm3_2 = imm3<<2u | imm2;",
                "    if (type == 0b00u && imm3_2==0b00000u) {",
                "      return MovRegisterT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "    } else if (type == 0b01u) {",
                "      return LsrImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "    } else if (type == 0b10u) {",
                "      return AsrImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "    } else if (type == 0b00u && imm3_2!=0b00000u) {",
                "      return LslImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "    } else if (type == 0b11u && imm3_2==0b00000u) {",
                "      return RrxT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "    }",
                "  } else if (op == 0b0010u && Rn != 0b1111u) {",
                "    return OrrRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b0100u && Rd != 0b1111u) {",
                "    return EorRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b0100u && Rd == 0b1111u && S==1) {",
                "    return TeqRegisterT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b0100u && Rd == 0b1111u && S==0) {",
                "    return Err<Instr>(StatusCode::kScDecoderUnpredictable);",
                "  } else if (op == 0b1101u && Rd != 0b1111u) {",
                "   return SubRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b1010u) {",
                "   return AdcRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b1011u) {",
                "   return SbcRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op == 0b1101u && Rd == 0b1111u) {",
                "   return CmpRegisterT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "} else if ((Bm16::Slice1R<10u, 9u>(rinstr.low) == 0b00u) && (Bm16::IsolateBit<6u>(rinstr.low) == 0b0u)) {",
                "  // ## Load Multiple and Store Multiple",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p144",
                "  const u16 op = Bm16::Slice1R<8u, 7u>(rinstr.low);",
                "  const u16 W = Bm16::IsolateBit<5u>(rinstr.low);",
                "  const u16 Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                "  const u16 L = Bm16::IsolateBit<4u>(rinstr.low);",
                "  const u16 W_Rn = (W<<4u) | Rn;",
                "  if ((op == 0b10u) && (L == 0u) && (W_Rn == 0b11101u)){ ",
                "    return PushT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((op == 0b01u) && (L == 0u) ){ ",
                "    return StmT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((op == 0b10u) && (L == 0u) && (W_Rn != 0b11101u)){ ",
                "    return StmdbT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ( (op == 0b01u) && (L == 1u) && (W_Rn != 0b11101u)) { ",
                "    return LdmT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ( (op == 0b01u) && (L == 1u) && (W_Rn == 0b11101u)) { ",
                "    return PopT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "} else if ((Bm16::Slice1R<10u, 9u>(rinstr.low) == 0b00u) && (Bm16::IsolateBit<6u>(rinstr.low) == 0b1u)) {",
                "  // ## Load/store dual or exclusive, table branch",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p145",
                "  const u16 op1 = Bm16::Slice1R<8u, 7u>(rinstr.low);",
                "  const u16 op2 = Bm16::Slice1R<5u, 4u>(rinstr.low);",
                "  const u16 op3 = Bm16::Slice1R<7u, 4u>(rinstr.high);",
                "  if (op1 == 0b00u && op2 == 0b00u) {",
                "    return StrexT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (op1 == 0b00u && op2 == 0b01u) {",
                "    return LdrexT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<1u, 1u>(op1) == 0b0u) && (op2 == 0b10u)) {",
                "    return StrdImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<1u, 1u>(op1) == 0b1u) && (Bm16::Slice1R<0u, 0u>(op2) == 0b0u)) {",
                "    return StrdImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<1u, 1u>(op1) == 0b0u) && (op2 == 0b11u)) {",
                "    return LdrdImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<1u, 1u>(op1) == 0b1u) && (Bm16::Slice1R<0u, 0u>(op2) == 0b1u)) {",
                "    return LdrdImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((op1 == 0b01u) && (op2 == 0b01u) && (op3 == 0b0000u)) {",
                "    return TbbHT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((op1 == 0b01u) && (op2 == 0b01u) && (op3 == 0b0001u)) {",
                "    return TbbHT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "}"
            ]
        },
        "32bit_op11110": {
            "flags": [
                "32bit"
            ],
            "splitters": [
                "// # 32-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p137",
                "const u16 op1 = Bm16::Slice1R<12u, 11u>(rinstr.low);",
                "const u16 op2 = Bm16::Slice1R<10u, 4u>(rinstr.low);",
                "const u16 op = Bm16::IsolateBit<15u>(rinstr.high);",
                "if ((op1 == 0b10u) && (op == 0b1u)) {",
                "  // ## Branches and miscellaneous control",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p142",
                "  const u16 _op1 = Bm16::Slice1R<14u, 12u>(rinstr.high);",
                "  const u16 _op = Bm16::Slice1R<10u, 4u>(rinstr.low);",
                "  if ((_op1 == 0b000u || _op1 == 0b010u) && (Bm16::Slice1R<5u, 3u>(_op)!=0b111u)) {",
                "    return BT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((_op1 == 0b000u || _op1 == 0b010u) && (Bm16::Slice1R<6u, 1u>(_op)==0b011100u)) {",
                "    return MsrT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((_op1 == 0b000u || _op1 == 0b010u) && (Bm16::Slice1R<6u, 1u>(_op)==0b011111u)) {",
                "    return MrsT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b001u || _op1 == 0b011u) { // attention the x in the docs does not mean hex",
                "    return BT4Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b101u || _op1 == 0b111u) {",
                "    return BlT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((_op1 == 0b000u || _op1 == 0b010u) && (_op == 0b0111011u)) {",
                "    // ### Miscellaneous control instructions",
                "    // see Armv7-M Architecture Reference Manual Issue E.e p143",
                "    const u16 _opc = Bm16::Slice1R<7u, 4u>(rinstr.high);",
                "    // const u16 _option = Bm16::Slice1R<3u, 0u>(rinstr.high);",
                "    if (_opc == 0b0101u) { ",
                "      return DmbT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "    }",
                "  }",
                "} else if ((op1 == 0b10u) && (Bm16::IsolateBit<5u>(op2) == 0b0u) && (op == 0x0u)) {",
                "  // ## Data processing (modified immediate)",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p138",
                "  const u16 _op = Bm16::Slice1R<8u, 4u>(rinstr.low);",
                "  const u16 _Rd = Bm16::Slice1R<11u, 8u>(rinstr.high);",
                "  const u16 _Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                "  if ((Bm16::Slice1R<4u, 1u>(_op) == 0b0000u)  && _Rd == 0b1111u) {",
                "    return TstImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4u, 1u>(_op) == 0b0000u)  && _Rd != 0b1111u) {",
                "    return AndImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4u, 1u>(_op) == 0b0010u)  && _Rn != 0b1111u) {",
                "    return OrrImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4u, 1u>(_op) == 0b0010u)  && _Rn == 0b1111u) {",
                "    return MovImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4u, 1u>(_op) == 0b0011u)  && _Rn == 0b1111u) {",
                "    return MvnImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4u, 1u>(_op) == 0b0100u)  && _Rd != 0b1111u) {",
                "    return EorImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4u, 1u>(_op) == 0b0100u)  && _Rd == 0b1111u) {",
                "    return TeqImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (Bm16::Slice1R<4u, 1u>(_op) == 0b0001u) {",
                "    return BicImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4u, 1u>(_op) == 0b1000u) && _Rd != 0b1111u) {",
                "    return AddImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);  ",
                "  } else if ((Bm16::Slice1R<4u, 1u>(_op) == 0b1000u) && _Rd == 0b1111u) {",
                "    return CmnImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (Bm16::Slice1R<4u, 1u>(_op) == 0b1010u) {",
                "    return AdcImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4u, 1u>(_op) == 0b1101u) && _Rd != 0b1111u) {",
                "    return SubImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<4u, 1u>(_op) == 0b1101u) && _Rd == 0b1111u) {",
                "    return CmpImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (Bm16::Slice1R<4u, 1u>(_op) == 0b1011u) {",
                "    return SbcImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (Bm16::Slice1R<4u, 1u>(_op) == 0b1110u) {",
                "    return RsbImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                " } else if ((op1 == 0b10u) && (Bm16::IsolateBit<5u>(op2) == 0b1u) && (op == 0x0u)) {",
                "  // ## Data processing (plain binary immediate)",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p141",
                "  const u16 _op = Bm16::Slice1R<8u, 4u>(rinstr.low);",
                "  const u16 _Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                "  if (_op == 0b00100u) {",
                "    return MovImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op == 0b00000u && _Rn != 0b1111u){",
                "    return AddImmediateT4Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op == 0b01010u && _Rn != 0b1111u){",
                "    return SubImmediateT4Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op == 0b10110u && _Rn != 0b1111u){",
                "    return BfiT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op == 0b11100u) {",
                "    return UbfxT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "}"
            ]
        },
        "32bit_op11111": {
            "flags": [
                "32bit"
            ],
            "splitters": [
                "// # 32-bit Thumb instruction encoding",
                "// see Armv7-M Architecture Reference Manual Issue E.e p137",
                "// op1 is set by jump table",
                "const u16 op2 = Bm16::Slice1R<10u, 4u>(rinstr.low);",
                "if ((Bm16::Slice1R<6u, 4u>(op2) == 0b000u) && (Bm16::Slice1R<0u, 0u>(op2) == 0b0u)) {",
                "   // ## Store single data item",
                "   // see Armv7-M Architecture Reference Manual Issue E.e p149",
                "   const u16 _op1 = Bm16::Slice1R<7u, 5u>(rinstr.low);",
                "   const u16 _op2 = Bm16::Slice1R<11u, 6u>(rinstr.high);",
                "   if (_op1 == 0b100u) {",
                "     return StrbImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b101u) {",
                "     return StrhImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b001u && Bm16::IsolateBit<5u>(_op2) == 0b1u) {",
                "     return StrhImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b000u && Bm16::IsolateBit<5u>(_op2) == 0b1u) {",
                "     return StrbImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b010u && Bm16::IsolateBit<5u>(_op2) == 0b1u) {",
                "     return StrImmediateT4Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b010u && Bm16::IsolateBit<5u>(_op2) == 0b0u) {",
                "     return StrRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b001u && Bm16::IsolateBit<5u>(_op2) == 0b0u) {",
                "     return StrhRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b000u && Bm16::IsolateBit<5u>(_op2) == 0b0u) {",
                "     return StrbRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b110u) {",
                "     return StrImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   }",
                "} else if ((Bm16::Slice1R<6u, 5u>(op2) == 0b00u) && (Bm16::Slice1R<2u, 0u>(op2) == 0b001u)) {",
                "   // ## Load byte, memory hints",
                "   // see Armv7-M Architecture Reference Manual Issue E.e p148",
                "   const u16 _op1 = Bm16::Slice1R<8u, 7u>(rinstr.low);",
                "   const u16 _op2 = Bm16::Slice1R<11u, 6u>(rinstr.high);",
                "   const u16 _Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                "   const u16 _Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                "   if (_op1 == 0b01u && _Rn != 0b1111 && _Rt != 0b1111u) {",
                "     return LdrbImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b00u && (Bm16::IsolateBit<5u>(_op2) == 0b1u) && (Bm16::Slice1R<2u, 2u>(_op2) == 0b1u) && _Rn != 0b1111 && _Rt != 0b1111u) {",
                "     return LdrbImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b00u && Bm16::Slice1R<5u, 2u>(_op2) == 0b1100u && _Rn != 0b1111 && _Rt != 0b1111u) {",
                "     return LdrbImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b11u && _Rn != 0b1111 && _Rt != 0b1111u) {",
                "     return LdrsbImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   }",
                "} else if ((Bm16::Slice1R<6u, 5u>(op2) == 0b00u) && (Bm16::Slice1R<2u, 0u>(op2) == 0b011u)) {",
                "   // ## Load halfword, memory hints",
                "   // see Armv7-M Architecture Reference Manual Issue E.e p147",
                "   const u16 _op1 = Bm16::Slice1R<8u, 7u>(rinstr.low);",
                "   const u16 _op2 = Bm16::Slice1R<11u, 6u>(rinstr.high);",
                "   const u16 _Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                "   const u16 _Rt = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                "   if (_op1 == 0b01u && _Rn != 0b1111u  && _Rt != 0b1111u) {",
                "     return LdrhImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b00u && (_op2 == 0b000000u) && _Rn != 0b1111u  && _Rt != 0b1111u) {",
                "     return LdrhRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b11u && _Rn != 0b1111u  && _Rt != 0b1111u) {",
                "     return LdrshImmediateT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b00u &&  Bm16::Slice1R<2u, 2u>(_op2) == 0b1u && Bm16::IsolateBit<5u>(_op2) == 0b1u &&_Rn != 0b1111u  && _Rt != 0b1111u) {",
                "     return LdrhImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b00u &&  Bm16::Slice1R<5u, 2u>(_op2) == 0b1100u && _Rn != 0b1111u  && _Rt != 0b1111u) {",
                "     return LdrhImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b10u &&  Bm16::Slice1R<2u, 2u>(_op2) == 0b1u && Bm16::IsolateBit<5u>(_op2) == 0b1u &&_Rn != 0b1111u  && _Rt != 0b1111u) {",
                "     return LdrshImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   } else if (_op1 == 0b10u &&  Bm16::Slice1R<5u, 2u>(_op2) == 0b1100u && _Rn != 0b1111u  && _Rt != 0b1111u) {",
                "     return LdrshImmediateT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "   }",
                "} else if ((Bm16::Slice1R<6u, 5u>(op2) == 0b00u) && (Bm16::Slice1R<2u, 0u>(op2) == 0b101u)) {",
                "  // ## Load word",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p146",
                "  const u16 _op1 = Bm16::Slice1R<8u, 7u>(rinstr.low);",
                "  const u16 _op2 = Bm16::Slice1R<11u, 6u>(rinstr.high);",
                "  const u16 _Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                "  if ((Bm16::Slice1R<1u, 1u>(_op1) == 0b0u) && _Rn == 0b1111u) {",
                "    return LdrLiteralT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b01u && _Rn != 0b1111u){",
                "    return LdrImmediateT3Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b00u && Bm16::IsolateBit<5u>(_op2) == 0b1u && (Bm16::Slice1R<2u, 2u>(_op2) == 0b1u)&& _Rn != 0b1111u) {",
                "    return LdrImmediateT4Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b00u && Bm16::Slice1R<5u, 2u>(_op2) == 0b1100u && _Rn != 0b1111u) {",
                "    return LdrImmediateT4Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b00u && _op2 == 0b000000u && _Rn !=0b1111u) {",
                "    return LdrRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "} else if (Bm16::Slice1R<6u, 4u>(op2) == 0b010u) {",
                "  // ## Data processing (register)",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p152",
                "  const u16 _op1 = Bm16::Slice1R<7u, 4u>(rinstr.low);",
                "  const u16 _op2 = Bm16::Slice1R<7u, 4u>(rinstr.high);",
                "  const u16 _Rn = Bm16::Slice1R<3u, 0u>(rinstr.low);",
                "  if ((Bm16::Slice1R<3u, 1u>(_op1) == 0b000u) && _op2 == 0b0000u) {",
                "    return LslRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<3u, 1u>(_op1) == 0b001u) && _op2 == 0b0000u) {",
                "    return LsrRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<3u, 1u>(_op1) == 0b010u) && _op2 == 0b0000u) {",
                "    return AsrRegisterT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b0001u && (Bm16::Slice1R<3u, 3u>(_op2) == 0b1u) && _Rn == 0b1111u) {",
                "    return UxthT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b0100u && (Bm16::Slice1R<3u, 3u>(_op2) == 0b1u) && _Rn == 0b1111u) {",
                "    return SxtbT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b0000u && (Bm16::Slice1R<3u, 3u>(_op2) == 0b1u) && _Rn == 0b1111u) {",
                "    return SxthT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b0101u && (Bm16::Slice1R<3u, 3u>(_op2) == 0b1u) && _Rn == 0b1111u) {",
                "    return UxtbT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if ((Bm16::Slice1R<3u, 2u>(_op1) == 0b10u) && (Bm16::Slice1R<3u, 2u>(_op2) == 0b10u)) {",
                "    // ## Miscellaneous operations",
                "    // see Armv7-M Architecture Reference Manual Issue E.e p155",
                "    const u32 __op1 = Bm16::Slice1R<5u, 4u>(rinstr.low);",
                "    const u32 __op2 = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                "    if ((__op1 == 0b11u) && (__op2 == 0b00u)) {",
                "      return ClzT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "    }",
                "  }",
                "} else if (Bm16::Slice1R<6u, 3u>(op2) == 0b0110u) {",
                "  // ## Multiply, multiply accumulate, and absolute difference",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p156",
                "  const u16 _op1 = Bm16::Slice1R<6u, 4u>(rinstr.low);",
                "  const u16 _op2 = Bm16::Slice1R<5u, 4u>(rinstr.high);",
                "  const u16 _Ra = Bm16::Slice1R<15u, 12u>(rinstr.high);",
                "  if (_op1 == 0b000u && _op2 == 0b00u && _Ra == 0b1111u) {",
                "    return MulT2Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b000u && _op2 == 0b00u && _Ra!=0b1111u) {",
                "    return MlaT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b000u && _op2 == 0b01u) {",
                "    return MlsT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "} else if (Bm16::Slice1R<6u, 3u>(op2) == 0b0111u) {",
                "  // ## Long multiply, long multiply accumulate, and divide",
                "  // see Armv7-M Architecture Reference Manual Issue E.e p156",
                "  const u16 _op1 = Bm16::Slice1R<6u, 4u>(rinstr.low);",
                "  const u16 _op2 = Bm16::Slice1R<7u, 4u>(rinstr.high);",
                "  if (_op1 == 0b010u && _op2 == 0b0000u) {",
                "    return UmullT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b000u && _op2 == 0b0000u) {",
                "    return SmullT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b011u && _op2 == 0b1111u) {",
                "    return UdivT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b001u && _op2 == 0b1111u) {",
                "    return SdivT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  } else if (_op1 == 0b110u && _op2 == 0b0000u) {",
                "    return UmlalT1Decoder<TProcessorStates, TItOps, TSpecRegOps>(rinstr, pstates);",
                "  }",
                "}"
            ]
        }
    },
    "opcodes": {
        "00000": {
            "decoder": "16bit_op00000"
        },
        "00001": {
            "decoder": "lsr_immediate_t1"
        },
        "00010": {
            "decoder": "asr_immediate_t1"
        },
        "00011": {
            "decoder": "16bit_op00011"
        },
        "00100": {
            "decoder": "mov_immediate_t1"
        },
        "00101": {
            "decoder": "cmp_immediate_t1"
        },
        "00110": {
            "decoder": "add_immediate_t2"
        },
        "00111": {
            "decoder": "sub_immediate_t2"
        },
        "01000": {
            "decoder": "16bit_op01000"
        },
        "01001": {
            "decoder": "ldr_literal_t1"
        },
        "01010": {
            "decoder": "16bit_op01010"
        },
        "01011": {
            "decoder": "16bit_op01011"
        },
        "10000": {
            "decoder": "strh_immediate_t1"
        },
        "01100": {
            "decoder": "str_immediate_t1"
        },
        "01101": {
            "decoder": "16bit_op01101"
        },
        "01110": {
            "decoder": "strb_immediate_t1"
        },
        "01111": {
            "decoder": "ldrb_immediate_t1"
        },
        "10001": {
            "decoder": "ldrh_immediate_t1"
        },
        "10010": {
            "decoder": "str_immediate_t2"
        },
        "10100": {
            "decoder": "add_pc_plus_immediate_t1"
        },
        "10101": {
            "decoder": "add_sp_plus_immediate_t1"
        },
        "10110": {
            "decoder": "16bit_op10110"
        },
        "10111": {
            "decoder": "16bit_op10111"
        },
        "10011": {
            "decoder": "ldr_immediate_t2"
        },
        "11010": {
            "decoder": "b_t1"
        },
        "11000": {
            "decoder": "stm_t1"
        },
        "11001": {
            "decoder": "ldm_t1"
        },
        "11011": {
            "decoder": "16bit_op11011"
        },
        "11100": {
            "decoder": "b_t2"
        },
        "11101": {
            "decoder": "32bit_op11101"
        },
        "11110": {
            "decoder": "32bit_op11110"
        },
        "11111": {
            "decoder": "32bit_op11111"
        }
    }
}